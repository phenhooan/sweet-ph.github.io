{"pages":[{"title":"标签","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Java Arrags API","text":"简介 Arrays位于Java.util包下 Arrays所有方法都是静态 System类中有一个arrayCopy方法 方法介绍 binarySearch() 12int[] nums = {1, 1, 5, 4, 2, 7, 4};int index = Arrays.binarySearch(nums, 5); copyOf()拷贝一个指定数组的副本 123456789101112131415161718192021222324252627282930313233343536373839int[] nums = {1, 1, 5, 4, 2, 7, 4};int[] nums01 = Arrays.copyOf(nums, nums.length + 1);System.out.println(Arrays.toString(nums01));/* * output: * [1, 1, 5, 4, 2, 7, 4, 0] */nums01 = Arrays.copyOf(nums, nums.length - 1);System.out.println(Arrays.toString(nums01));/* * output: * [1, 1, 5, 4, 2, 7] */nums01 = Arrays.copyOf(nums, 2, nums.length);System.out.println(Arrays.toString(nums01));/* * output: * [5, 4, 2, 7, 4] *///数组合并int nums02[] = {1, 2, 3, 4, 5};int nums03[] = {6, 7, 8, 9, 10};nums02 = Arrays.copyOf(nums02, nums02.length + nums03.length)System.out.println(Arrays.toString(nums02));/* * output: * [1, 2, 3, 4, 5, 0, 0, 0, 0, 0] */ System.arraycopy(nums03, 0, nums02, 5, nums03.length); //src srcPos dest destPos length(src) System.out.println(Arrays.toString(nums02)); /* * output: * [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] */ equals(); 12345int nums01[] = {1, 2, 3, 4, 5};int nums02[] = {1, 2, 3, 4, 5};int nums03[] = {6, 7, 8, 9, 10};Arrays.equals(nums01, nums02);//return true fill() 12345678910111213141516int nums01[] = {1, 2, 3, 4, 5};System.out.println(Arrays.toString(nums01));Arrays.fill(nums01, 8);System.out.println(Arrays.toString(nums01));/* * output: * [1, 2, 3, 4, 5] * [8, 8, 8, 8, 8] */Arrays.fill(nums01, 0, 2, 6);System.out.println(Arrays.toString(nums01));/* * output: * [6, 6, 8, 8, 8] */ sort() 12345678910111213byte[] nums01 = {9, 2, 8, 4, 3};char[] nums02 = {'a', 'z', '啊', 'V'};Arrays.sort(nums01);System.out.println(Arrays.toString(nums01));Arrays.sort(nums02);System.out.println(Arrays.toString(nums02));/* output: * [2, 3, 4, 8, 9] * ['V', 'a', 'z', '啊'] */ //降序 https://blog.csdn.net/wang_123_zy/article/details/89480457 Arrays.sort(nums02, Collections.sortOrder());","link":"/2019/11/14/Java Arrays API/"},{"title":"Java JDBC连接mysql数据库","text":"连接1234567891011121314151617181920private static final String JDBC_DRIVER = \"com.jdbc.cj.mysql.Driver\";private static final String DB_URL = \"jdbc:mysql://localhost:3306/study?userSSL=false&amp;serverTimeZone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8\";private static final String USER = \"root\";private static final String PASS = \"ph1234\";Connection conn = null;Statement stmt = null;try{ //通过反射，注册驱动 Class.forName(JDBC_DRIVER); //建立连接， 获得连接对象 conn = DriverManager.getConnection(DB_URL, USER, PASS); //创建执行集 stmt = conn.cerateStatement(); //根据执行集执行 创建结果集 String sql = \"select * from user\"; ResultSet rs = stmt.execute(sql);} 事务的概念数据库事务(database transaction):是由相关逻辑操作构成的一个完整的程序执行单元，两次连续成功的Commit或RollBack之间的操作，称为一个事务。在一个事务内，数据库的提交或撤销，如果发生错误，那么该事务会被撤销。 乐观锁：允许多个人操作，不安全。悲观锁：同一时刻只允许一个人操作，安全。 JDBC的Connection默认在关闭的时候自动提交没有提交的DML(增删改)操作 setAutoCommit(boolean): 设置事务是否自动提交，默认一行一提交。commit(): 提交事务rollback(): 回滚事务 事务的特性 原子性: 事务必须是原子单元一致性: 事务使数据库从一致性状态变到另一个一致性状态隔离性: 一个事务的执行不能被其他事务干扰持久性: 一旦提交，对数据库的数据改变就是永久性的 事务的隔离级别 Read uncommited(读到未提交的数据) 就是一个事务读取到另一个事务未提交的数据 Read commited(读取已提交的数据) Repeatable read(可重复读) Serializable(串行化) 事务隔离级别 脏读 不可重复读 不可串行化 使用 Read uncommited 是 是 是 不推荐 Read commited 否 是 是 Orcal默认使用 Repeatable read 否 否 是 mysql默认使用 Serializable 否 否 否 效率低","link":"/2019/12/03/Java JDBC连接mysql/"},{"title":"Java IO流","text":"File 在java中 File包含了文件、目录(文件夹) 从文件中读取(in) 缓存到程序中; 从系统写入(out)到磁盘。 I/O流： 字节流、字符流 File文件路径 12345678public static void createFile(){ //创建一个文件对象的时候不需要路径中文件真实存在 File file = new File(\"C:\\\\io\\\\test.txt\"); //返回构造函数中写入的路径 String path = file.getPath(); //返回文件真实存在的绝对路径(全路径) String absolute = file.getAbsolutePath();} File是文件还是目录 1234567891011public static void fileOrDirectory(){ File file01 = new File(\"D:\\\\io\"); File file02 = new File(\"D:\\\\io\\test.txt\");// 只有当我们调用file对象时，才会需要文件真实存在 file01.isFile(); //false file01.isDirectory(); //true file02.isFile(); //true file02.isDirectory(); //flase} File权限 123456789101112public static void fileRight(){ File file01 = new File(\"D:\\\\io\"); File file02 = new File(\"D:\\\\io\\test.txt\"); file01.canRead(); file01.canWrite(); file01.canExecute(); file02.canRead(); file02.canWrite(); file02.canExecute();} File相关操作 123456789101112131415public static void fileHandle(){ File file01 = new File(\"D:\\\\io\"); File file02 = new File(\"D:\\\\io\\\\test.txt\"); File file03 = new File(\"D:\\\\io_new\"); //判断文件是否存在 file01.exists(); //获取File文件名 file01.getName(); //改File名， 参数为文件对象 file01.renameTo(file03); //File 字节大小 file01.length();} File创建文件夹和文件 12345678910public static void makeFileOrDir(){ File file01 = new File(\"D:\\\\io\"); File file01 = new File(\"D:\\\\io\\temp.txt\"); if(!file01.exists()) file01.mkDir(); if(!file02.exists()) file02.createNewFile();} 慎用renameTo()去移动文件，使用copy() 12345678910111213141516171819202122public static void testRename(){ File sourceFile = new File(\"c:/test.txt\"); File targetFile1 = new File(\"e:/test.txt\"); File targetFile2 = new File(\"d:/test.txt\"); System.out.println(\"source file is exist? \" + sourceFile.exists() + \", source file =&gt; \" + sourceFile); System.out.println(targetFile1 + \" is exist? \" + targetFile1.exists()); System.out.println(\"rename to \" + targetFile1 + \" =&gt; \" + sourceFile.renameTo(targetFile1)); System.out.println(\"source file is exist? \" + sourceFile.exists() + \", source file =&gt; \" + sourceFile); System.out.println(targetFile2 + \" is exist? \" + targetFile2.exists()); System.out.println(\"rename to \" + targetFile2 + \" =&gt; \" + sourceFile.renameTo(targetFile2)); /* * Output: * * source file is exist? true, source file =&gt; c:\\test.txt * e:\\test.txt is exist? false * rename to e:\\test.txt =&gt; false * source file is exist? true, source file =&gt; c:\\test.txt * d:\\test.txt is exist? false * rename to d:\\test.txt =&gt; true */} 注意看结果，从C盘到E盘失败了，从C盘到D盘成功了。因为我的电脑C、D两个盘是NTFS格式的，而E盘是FAT32格式的。所以从C到E就是上面文章所说的”file systems”不一样。从C到D由于同是NTFS分区，所以不存在这个问题，当然就成功了。 果然是不能把File#renameTo(File)当作move方法使用。 可以考虑使用apache组织的commons-io包里面的FileUtils#copyFile(File,File)和FileUtils#copyFileToDirectory(File,File)方法实现copy的效果。至于删除嘛，我想如果要求不是那么精确，可以调用File#deleteOnExit()方法，在虚拟机终止的时候，删除掉这个目录或文件。 字节流 字节输入流 1234567891011121314151617181920212223242526public static void readFile(String filePath){ InputStream input ; try{ input = new FileInputStream(filepath);//*************可改造部分************** while(true){ int n = input.read(); if(n == -1) break; System.out.println(n);//************************************** } }catch(FileNotFoundException e){ e.printStackTrace(); }catch(IOException e){ e.printStackTrace(); }finally{ try{ if(null != input) input.close(); }catch(IOException e){ e.printStackTrace(); } }} 利用缓冲区改造 123456789while(true){ byte[] buffer = new byte[1024]; int n = input.read(buffer); // input.read(buffer, 0, n); for(byte b : byte) System.out.println(b); if(n == -1) break;} 超出缓冲区大小，则第二次覆盖第一次的缓冲区。若缓冲区大小为2，需读取三个数据123。将出现1231现象，出现数据出错。将使用其重载方法(byte[], offset, size) 字节输出流(OutputStream) 123456789public static void writeToFile(String filePath){ OutputStream output = new FileOutputStream(filePath); output.write(72); output.write(101); output.write(108); output.write(108); output.write(111); output.close();} 同样的OutputStream也支持byte数组形式 1output.write(\"中文字符\".getBytes(\"GBK\")); 引入flush()提高效率当我们使用输出流发送数据时，当数据不能填满输出流的缓冲区时，这时，数据就会被存储在输出流的缓冲区中。如果，我们这个时候调用关闭(close)输出流，存储在输出流的缓冲区中的数据就会丢失。所以说，关闭(close)输出流时，应先刷新(flush)换冲的输出流，话句话说就是：“迫使所有缓冲的输出数据被写出到底层输出流中” 字符流转换流source –GBK–&gt; byte –UTF-8–&gt; target 复制过程将源文件 解码为字节 粘贴就是将字节编码为 指定文件如果编码于解码方式不同，那么将会出现乱码 12OutputStream outer = new FileOutputStream(filePath); //将源文件转换为字节OutputStreamWriter osw = new OutputStreamWriter(outer, encoding);","link":"/2019/11/21/Java IO流/"},{"title":"Java常用类","text":"日期类 java.util.datedate获取的getYear()年份需要加1900 getMonth()月份需加1 getDate()日期不做处理GMT时区：格林威治 12345678910111213public class DateTest{ public static void main(String[] args){ Date date = new Date(); SimpleDateFormat form = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String time = form.format(date); System.out.println(time); /* * output * 2019-11-15 09:27:56 */ }} java.util.Calendar 12345678910111213141516171819202122232425262728public class CalendarTest{ public static void main(String[] args){ Calendar calendar = Calendar.getInstance; calendar.get(Calendar.YEAR); calendar.get(Calendar.MONTH) + 1; calendar.get(Calendar.DAY_OF_MONTH); calendar.get(Calendar.DAY_OF_WEEK) - 1; calendar.get(Calendar.HOUR_OF_DAY); calendar.get(Calendar.MINUTE); calendar.get(Calendar.SECOND); calendar.get(Calendar.MILLISECOND); TimeZone zone = TimeZone.getDafualt(); TimeZone zone = TimeZone.getTimeZone(\"\"); Date date = calendar.getTime(); SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String time = format.format(date); System.out.println(time); /* * output * 2019-11-15 09:27:56 */ }} java.time.* 时间戳(Instant) 当前时间到1970年1月1日之间的毫秒数 时区(ZoneId) 时间间隔(Duration) 1234567891011121314151617public class LocalDateTime{ public static void main(String[] args){ //当前日期(年月日) LocalDate d = LocalDate.now(); //当前时间(时分秒) LocalTime t = LocalTime.now(); //当前日期和时间 //ISO 8601规定规定日期和时间之间分隔符是T //以P...T... (P...T之间表示年月日,T之后表示时分秒) LocalDateTime dt = LocalDateTime.now(); //将字符串转换为LocalDateTime对象 d = LocalDate.parse(\"2019-11-15\"); t = LocalTime.parse(\"10:22:45\"); dt = LocalDateTime.parse(\"2019-11-15T10:22:45\"); //默认解析方法，还有带DateTimeFormatter对象的重构方法 }} Temporal() adjustInto() –&gt; public Temporal adjustInto(Temporal temporal)一般用于 LocalDate | LocalTime.adjustInto(LocalDateTime),即，将LocalDate或LocalTime插入到LocalDateTime相对应的部分。例: 12345678910LocalDate date = LocalDate.of(2019, 11, 11);LocalTime time = LocalTime.of(11, 11, 11);LocalDateTime dt = LocalDateTime.of(2019, 1, 1, 1, 1, 1);LocalDateTime newDt = date.adjustInto(dt);System.out.println(newDt);/* * output: * 2019-11-11 01:01:01 */ atOffset() –&gt; public OffsetDateTime atOffset(ZoneOffset offset) 1LocalDateTime dateTime = LocalDateTime.now(); with()该方法可以调整LocalDate对象的值 123456LocalDate date = LocalDate.of(2019, 11, 11);localDate nextMonthFirstDay = date.with(TemporalAdjusters.firstDayOfNextMonth())//nextMonthFirstDay ---&gt; 2019-12-1LocalDate firstWorkday = d.with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));//firstWorkday:2019-11-04 求LocalDate或LocalTime以及LocalDateTime 之间的间隔 123456789101112131415// 起始日期和时间LocalDateTime start = LocalDateTime.of(2019, 11, 19, 8, 15, 0);// 结束日期和时间LocalDateTime end = LocalDateTime.of(2020, 1, 9, 19, 25, 30);// Duration计算两个时刻间间隔的时分秒Duration d = Duration.between(start, end);System.out.println(d); // PT1235H10M30S// Period计算两个时刻间的间隔年月日Period p = LocalDate.of(2019, 11, 19).until(LocalDate.of(2021, 1, 9));System.out.println(p); // P1Y1M21D// Duration和Period的表示方法也符合ISO 8601的格式，它以P...T...的形式表示，// P...T之间表示年月日间隔，T后面表示时分秒间隔。如果是PT...的格式表示仅有时分秒间隔。 时区时间(ZoneDateTime)使用LocalDateTime.atZone(ZoneId id)的方法将LocalDateTime(本地时间)转换为带有时区的ZoneDateTime时区时间使用ZoneDateTime.withZoneSameInstant(ZoneId id)方法获取同一时刻不同时区的时间(表面值不同)例如： 1234567891011121314//北京时间和纽约时间相差13个小时final LocalDateTime beijingDateTime = LocalDateTime.of(2019, 11, 15, 15, 30, 00);ZonedDateTime beijing = ZonedDateTime.of(beijingDateTime, ZoneId.of(BEIJING_ZONE_ID));ZonedDateTime newYork = beijing.withZoneSameInstant(ZoneId.of(NEW_YEAR_ZONE_ID));LocalDateTime time01 = beijing.toLocalDateTime();LocalDateTime time02 = newYork.toLocalDateTime();System.out.println(time01);System.out.println(time02);/* * output * 2019-11-16T04:50 * 2019-11-15T15:50 * */","link":"/2019/11/15/Java 常用类/"},{"title":"Java 网络编程","text":"概述JDK预定义的网络编程有关类在java.net包下 InetAddress — IP Socket 和 ServerSocket — TCP/IP DatagramPacket 和 DatagramSocket — UDP URL 和 URLConnection — HTTP URLEncoder 和 URLDecoder IP12345IntAddress address = IntAddress.getLocalHost(); //DESKTOP-I7I7I7/172.17.1.220address.getHostName();address.getHostAddress();address = IntAddress.getByName(\"172.0.0.1\"); TCP/IP服务器端 12345678910111213141516171819202122public class Server extends Thread{ ServerSocket server = new ServerSocket(8000); //实例化一个服务器端Socket端口号为8000 while(true){ Socket socket = serverSocket.accept(); //阻塞，接收客户端的socket InputStream input = socket.getInputStream(); //获取输入流 OutputStream output = socket.getOutputStream(); //获取输出流 DataInputStream dataIn = new DataInputStream(input); //实例化数据输入流 DataOutputStream dataOut = new DataOutputStream(output) //实例化数据输出流 dataIn.readUTF(); //以UTF-8的解码方式获取一个字符串 dataIn.writeUTF(); //以UTF-8的编码方式写入一个字符串 //关闭所有的流 dataOut.close(); dataIn.close(); output.close(); intput.close(); socket.close(); }} 客户端 123456public class Client{ //实例化一个客户端Socket，IP参数与服务器IP一致，端口号与服务器端口一致 Socket client = new Socket(\"172.0.0.1\", 8000); //........... //与以上的内容类似 通过流对服务器端 进行发送和接收消息} TCP/IP案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package day024;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;import java.net.UnknownHostException;/** * * Java网络编程 - Socket 编程(TCP / IP) * * @author Koper * */public class SocketTCPClient extends Thread { private String serverName; private int port; public SocketTCPClient() { } public SocketTCPClient(String serverName, int port) throws IOException { this.serverName = serverName; this.port = port; } /** * 客户端实例化一个 Socket 对象，指定服务器名称和端口号，请求连接正在等待的服务器 * * @param serverName * @param port * @return * @throws UnknownHostException * @throws IOException */ public static Socket connection(String serverName, int port) throws UnknownHostException, IOException { System.out.println(\"连接到Server：\" + serverName + \" ，端口号：\" + port); Socket socket = new Socket(serverName, port); return socket; } /** * 连接建立后, 通过 Socket 创建输入流，负责接收消息 * * @param client * @return * @throws IOException */ public static DataInputStream input(Socket socket) throws IOException { InputStream inFromServer = socket.getInputStream(); DataInputStream in = new DataInputStream(inFromServer); System.out.println(\"服务器响应： \" + in.readUTF()); return in; } /** * 连接建立后, 通过 Socket 创建输出流，负责发送消息 * * @param client * @return * @throws IOException */ public static DataOutputStream output(Socket socket) throws IOException { OutputStream outToServer = socket.getOutputStream(); DataOutputStream out = new DataOutputStream(outToServer); out.writeUTF(\"Hello \" + socket.getRemoteSocketAddress()); //out.writeUTF(\"Hello from \" + socket.getLocalSocketAddress()); return out; } /** * 通信完成,关闭相关流 * * @param client * @param out * @param in * @throws IOException */ public static void close(Socket socket, DataOutputStream out, DataInputStream in) throws IOException { out.close(); in.close(); socket.close(); } @Override public void run() { try { // 1. 创建 Socket对象，跟 ServerSocket 建立连接 Socket client = connection(serverName, port); // 2. 连接建立后，通过使用 I/O 流在进行通信，每一个socket都有一个输出流和一个输入流 // 输出流，负责发送消息 DataOutputStream out = output(client); // 输入流，负责接收消息 DataInputStream in = input(client); // 3. 通信完成,关闭相关流 close(client, out, in); } catch (UnknownHostException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } public static void main(String[] args) { Thread thread; try { thread = new SocketTCPClient(\"127.0.0.1\", 8000); thread.run(); } catch (IOException e) { e.printStackTrace(); } }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139package day024;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.net.SocketTimeoutException;import java.net.UnknownHostException;/** * * Java网络编程 - Socket 编程(TCP / IP) * * Socket使用TCP提供了两台计算机之间的通信机制。 客户端和服务器可以通过对 Socket 对象的写入和读取来进行通信。 * java.net.Socket 类代表一个套接字， java.net.ServerSocket * 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。 * * 以下步骤在两台计算机之间使用套接字建立TCP连接时会出现： * * JDK编程相关类： * * InetAddress * * Socket、ServerSocket 和 SocketImpl * * @author Koper * */public class SocketTCPServer extends Thread { private ServerSocket serverSocket; public SocketTCPServer(){ } public SocketTCPServer(int port) throws IOException { // 服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信 serverSocket = new ServerSocket(port); // serverSocket.setSoTimeout(10000); } /** * Server端通过 ServerSocket 对象，接收 Client 传递的 Socket 对象 * * @param serverSocket * @return * @throws UnknownHostException * @throws IOException */ public Socket connection(ServerSocket serverSocket) throws UnknownHostException, IOException { System.out.println(\"等待远程连接... 端口号为：\" + serverSocket.getLocalPort()); // 服务器 调用 ServerSocket 类的 accept() 方法，该方法将一直等待， // 直到客户端连接到服务器上给定的端口。 Socket socket = serverSocket.accept(); System.out.println(\"连接成功的Client地址：\" + socket.getRemoteSocketAddress()); return socket; } /** * 连接建立后, 通过 Socket 创建输入流，负责接收消息 * @param client * @return * @throws IOException */ public static DataInputStream input(Socket socket) throws IOException { InputStream inFromClient = socket.getInputStream(); DataInputStream in = new DataInputStream(inFromClient); System.out.println(\"客户端消息： \" + in.readUTF()); return in; } /** * 连接建立后, 通过 Socket 创建输出流，负责发送消息 * @param client * @return * @throws IOException */ public static DataOutputStream output(Socket socket) throws IOException { OutputStream outToClient = socket.getOutputStream(); DataOutputStream out = new DataOutputStream(outToClient); out.writeUTF(\"客户端-\" + socket.getLocalSocketAddress() + \"你已成功连接我 -- goodbye!\"); return out; } /** * 通信完成,关闭相关流 * * @param client * @param out * @param in * @throws IOException */ public static void close(Socket socket, DataOutputStream out, DataInputStream in) throws IOException { out.close(); in.close(); socket.close(); } @Override public void run() { while (true) { try { // 1. Server端通过 ServerSocket 对象，等待接收 Client 传递的 Socket 对象 Socket client = connection(serverSocket); /* // 2. 连接建立后，通过使用 I/O 流在进行通信，每一个socket都有一个输出流和一个输入流 // 输入流，负责接收消息 DataInputStream in = input(client); // 输出流，负责发送消息 DataOutputStream out = output(client); // 3. 通信完成,关闭相关流 close(client, out, in);*/ } catch (SocketTimeoutException s) { System.out.println(\"Socket timed out!\"); break; } catch (IOException e) { e.printStackTrace(); break; } } } public static void main(String[] args) { // Server端口号 int port = 8000; try { Thread thread = new SocketTCPServer(port); thread.run(); } catch (IOException e) { e.printStackTrace(); } }} URL(Uniform Resource Locator)12String urlStr = \"\";Url url = new Url(urlStr);","link":"/2019/11/22/Java 网络编程/"},{"title":"Java 集合Map","text":"Map在通讯录中的应用123456789101112131415161718192021222324public class TestMap{ public static void main(String[] args){ Contacts con01 = new Contacts(\"XiaoMing\", 13800138000L); Contacts con02 = new Contacts(\"XiaoXiaoMing\", 13900138000L); Contacts con03 = new Contacts(\"XiaoMingMing\", 13600138000L); Map&lt;String, Contacts&gt; map = new HashMap&lt;String, Contacts&gt;(); map.put(\"XiaoMing\", con01); map.put(\"XiaoXiaoMing\", con02); map.put(\"XiaoMingMing\", con03); //put()方法，键名不能重复，若重复，则覆盖。 }} class Contacts{ private String name; private Long number; public Contacts(){} public Contacts(String name, Long number){ this.name = name; this.number = number; } } Map的遍历12345678910Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();map.put(\"apple\", 123);map.put(\"orange\", 456);for(String key : map.keySet()) System.out.println(map.get(key));for(Map.entry&lt;String, Integer&gt; entry : map.entrySet()){ System.out.println(entry.getKey()); System.out.println(entry.getValue());}","link":"/2019/11/19/Java 集合Map/"},{"title":"Java String... API","text":"append()方法12 StringBuffer内置方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556StringBuffer buff = new StringBuffer();char[] chars = {'X', 'Y', 'Z'};buff.append(chars).append(123).append(\"你好吗？\");System.out.println(\"buff:\" + buff);/* output: * buff:XYZ123你好吗？ *///在索引为3的地方插入999buff.insert(3, 999);System.out.println(\"buff:\" + buff);/* output: * buff:XYZ999123你好吗？ *///删除索引为3的字符 buff.deleteCharAt(3); System.out.println(\"buff:\" + buff); /* output: * buff:XYZ99123你好吗？ */ //删除[3, 5)的字符 buff.delete(3, 5); System.out.println(\"buff:\" + buff);/* output: * buff:XYZ123你好吗？ *///替换[0, 3)位置字符串 为 abcbuff.replace(0, 3, \"abc\");System.out.println(\"buff:\" + buff);/* output: * buff:abc123你好吗？ *///设置索引为0位置的字符为A, 仅针对字符buff.setCharAt(0, 'A');System.out.println(\"buff:\" + buff);/* output: * buff:Abc123你好吗？ */ //将buff字符串反转buff.reverse();System.out.println(\"buff:\" + buff);/* output: * buff:?吗好你321cbA */ 测试String StringBuffer StringBuilder效率123456789101112131415161718192021222324252627String chars = \"XYZ\";long startTime;long endTime;startTime = System.currentTimeMillis();String str = new String();for(int i = 0; i &lt; 66666666; i++) str.concat(chars);endTime = System.currentTimeMillis();System.out.println(\"String拼接耗时 \" + (endTime - startTime) + \"ms\");startTime = System.currentTimeMillis();StringBuffer strbuff = new StringBuffer();for (int i = 0; i &lt; 66666666; i++) strbuff.append(chars);endTime = System.currentTimeMillis();System.out.println(\"StringBuffer拼接耗时 \" + (endTime-startTime) + \"ms\"); //StringBuilder拼接耗时startTime = System.currentTimeMillis();StringBuilder strbuil = new StringBuilder();for (int i = 0; i &lt; 66666666; i++) { strbuil.append(chars);}endTime = System.currentTimeMillis();System.out.println(\"StringBuilder拼接耗时 \" + (endTime-startTime)) + \"ms\"; StringJoiner12345678910111213StringJoiner joiner = new StringJoiner(\", \");//元素后面追加\", \"String[] names = new String[]{\"Alice\", \"Bob\"};for(String name: names) joiner.add(name)//Alice,Bob,joiner = new StringJoiner(\",\", \"Hello\", \"!\");//args 分隔符,头部, 尾部for(String name: names) joiner.add(name)//Hello,Alice,Bob!String str = String.join(\", \", names);//不提供头部，尾部 使用\", \"作为分隔符//Alice,Bob","link":"/2019/11/14/Java String StringBuff StringBuilder API/"},{"title":"Java 集合List","text":"集合的由来 处理多个相同类型的数据我们采用数组，但数组空间固定不能动态改变(增加 删除 插入)，所以采用集合。 集合和数组的特点集合特点：元素类型可以不同、集合长度可变、空间不固定。数组特点：元素类型必须相同、数组长度不可变、空间固定。 java中对一些数据结构和算法进行了封装即集合，集合也是一种对象，用于存储、检索、和传输对象。 JCF(Java Collections Framework)集合框架。它提供了用于管理集合的接口和类。 List接口简述：一类数据，数据内容可以重复，以元素安插的次序存储元素，每个元素都通过索引确定自己的位置，所以可以重复。 最常用的List接口实现类ArrayList 12List list = new ArrayList();System.out.println(\"- list size - \" + list.size()); 集合可以存放不同类型的元素 1234// ........list.add(123);list.add(\"456\");list.add(789.0); 可以添加重复元素 1list.add(123); 可以添加null 1list.add(null); 输出数组元素 12345System.out.println(list);/* * Output: * [123, 456, 789.0, 123, null] */ LinkedList1234List&lt;String&gt; list02 = new LinkedList&lt;String&gt;();list02.add(\"banana\");list02.add(\"coconut\");list02.add(\"orange\"); ArrayList 和 LinkedList 的比较 ArrayList是一个顺序结构, 随机访问的效率更高，因为含有索引。 LinkedList是一个链式结构, 首尾插入与删除效率高，因为是二分查找。针对结构比较 表一 ArryList LinkedList 原因 添加到末尾 速度慢 速度快 Linked(二分查找),检索耗时少 插入到中间位置 速度快 速度慢 Linked查找耗时大于移动元素耗时 移除到中间位置 速度快 速度慢 Linked查找耗时大于移动元素耗时 get获取元素 速度快 速度慢 顺序结构有索引，链式需从头到尾检索 内存占用 占用少 占用多 链式结构结构体复杂 占用内存空间大 上述问题，含有不准确的情况。总结如下： 针对位置比较 表二 ArrayList LinkedList 在首部 插入数据慢，因为数组复制的方式移位耗时多。 插入数据很快，因为遍历链表指针（二分查找）耗时少，因为只需要修改插入元素前后节点的prev值和next值即可。 在中间 插入数据快，因为定位插入元素位置快，移位操作的元素没那么多。 插入数据慢，因为遍历链表指针（二分查找）耗时多。 在尾部 插入速度不确定，定位快，移位数据少 插入速度不确定，因为遍历链表指针（二分查找）耗时少。 删除也类似，尾部操作不确定，ArrayList插入涉及到扩容，删除却不影响容量。理由如下:ArrayList是基于动态数组的，有扩容耗时；而LinkedList是通过new一个Node再改变指针添加元素。ArrayList需要扩容，所以LinkedList的效率就会比较高，其中如果ArrayList出现不需要扩容的时候，那么ArrayList的效率应该是比LinkedList高的，当数据量很大的时候，new对象的时间大于扩容的时间，那么就会出现ArrayList’的效率比Linkedlist高了。扩容机制：length = 1.5 * length 泛型集合加入泛型的原因：使用方便，指定一个类型，不必考虑取用时类型的差异。 迭代器List不推荐使用get(int)方法取用元素，一是只有ArrayList是高效的，开销大; 二是代码复杂。若是LinkedList，索引越大，从头开始找，访问速度越慢，检索范围广，花销大。 12345Iterator&lt;String&gt; iterator = list.iterator();while(iterator.hasNext()){ String str = iterator.next(); System.out.println(\"--list items-- \" + str);} 优点： Iterator访问List，该对象由List的实例调用创建，它可以针对List的实现类型不同，从而使用该List实现类对象的最高访问效率的方式遍历该List对象 1234//由于语法复杂，因为for-each本身的实现就是使用了Iteractor访问List//因此推荐使用for-each的方式遍历for(String str : list) System.out.println(str); 普通的迭代器和for-each只能正序的输出元素，针对List有一个特殊的迭代器ListIterator 1234ListIterator&lt;String&gt; iteratr = list.listIterator();while(iterator.hasProvious()){ System.out.println(iterator.provious());} List与数组相转换123456List list = new ArrayList();//丢失类型Object[] objs = list.toArray();//类型转换必须相对应//如果给的长度不够则自动增加，长度超出则，多出元素为类型默认值 Integer[] arrays = list.toArray(new Integer[list.size()]);","link":"/2019/11/19/Java 集合List/"},{"title":"Java 集合Set","text":"Set集合概述：Set存储不重复的元素 Set基本使用123456789Set&lt;String&gt; set = new HashSet&lt;String&gt;();System.out.println(set.add(\"abc\"));//trueSystem.out.println(set.add(\"xyz\"));//trueSystem.out.println(set.add(\"xyz\"));//falseSystem.out.println(set.contains(\"xyz\"));//trueSystem.out.println(set.contains(\"XYZ\"));//falseSystem.out.println(set.remove(\"hello\"));//falseSystem.out.println(set.size());System.out.println(\"-- set --\" + set) Set集合有自己的一套排序规则，在不同的JDK当中有可能不同。 Set子接口SortedSet下的TreeSet","link":"/2019/11/19/Java 集合Set/"},{"title":"Java 集合Vector、Stack、HashTable","text":"VectorVector与ArrayList的用法类似, 两者的差别在于Vector类是线程安全的，而ArrayList不是 HashTableHashTable与HashMap的用法也类似，HashTable是线程安全的，而HashMap不是；HashTable不允许key和value为null，而HashMap是允许的。 StackStack是一种后进先出(LIFO: Last In First Out)的一种数据结构Stack只有入栈和出栈的操作：把元素压栈：push(E) 把栈顶元素“弹出”：pop(E) 取栈顶元素但不弹出peek(E) Queue Queue是一种先进先出(FIFO: First In First Out)的一种数据结构 –&gt; Queue可以改造成双向队列，在两端都可以进行Add和Remove操作–&gt; 双向队列也可以改装成Stack类似的操作，因此经常使用双向队列代替栈的操作 队列只能进行两个操作：添加到末尾，从头部取出元素(车票售票窗口) 12345List&lt;String&gt; list = new LinkedList&lt;String&gt;();//没有最大的容量限制Queue&lt;String&gt; queue01 = new LinkedList&lt;String&gt;();//拥有最大的容量限制为2Queue&lt;String&gt; queue02 = new LinkedBlockingDeque&lt;Stirng&gt;(2); Queue接口拥有6个方法，总结为三套方法，增加，删除，取值boolean add(E e)/boolean offer(E e)在尾部增加一个元素E element()/E peek()取用首部的元素，但不删除E remove()/E poll()删除首部的元素 add()/offer() 123456789Queue&lt;Stirng&gt; queue01 = new LinkedBlockingDeque&lt;String&gt;(2);queue01.add(\"Banana\");queue01.add(\"Orange\");queue01.add(\"Apple\");/* Output: * java.lang.IllegaStateException */queue.offer(\"Apple\"); //返回false，但不会抛出异常 remove()/poll() 123456Queue&lt;Stirng&gt; queue02 = new LinkedBlockingDeque(String)(2);queue02.remove(); //会抛出异常/* Output: * java.lang.NoSuchElementsException */ queue02.poll(); //获取队首的元素，然后再删除，因此不会报错 特别注意：不要将null添加到元素队列中，否则无法判断队列是否为空 element()/peek()123456Queue&lt;Stirng&gt; queue03 = new LinkedBlockingDeque(String)(2);queue03.element(); //会抛出异常/* Output: * java.lang.NoSuchElementsException */ queue03.peek(); //获取队首的元素，然后再删除，因此不会报错 PriorityQueue 引入，银行窗口，出现VIP则出现插队现象 123456 Queue&lt;String&gt; queue = new PriorityQueue&lt;String&gt;(); queue.offer(\"A1\"); queue.offer(\"A2\"); queue.offer(\"V1\"); queue.offer(\"A3\");// 排序后 A1 A2 A3 V1 如果实现特殊的排序方式，则需要自定义的比较器java.lang.Comparable 自己是比较的参与者，内比较器java.util.Comparator 自己不是比较的参与者，让其他两者比较 1234567891011121314class Person implements Comparable&lt;Obejct&gt;{ private String name; private int age; //getter/setter... @Overwrite public int compareTo(Object object){ Person person = (Person) object; return (this.name.compareTo(person.getName()) == 0) ? ((this.age - person.age) &gt; 0 ? 1 : -1) : 、 this.name.compareTo(person.getName()); }} 123456public class Mycomparator implements Comparator&lt;MyClass&gt;{ @Overwrite public int compareTo(MyClass mc1, MyClass mc2){ //............... return 0; } 使用比较器比较过后不要使用foreach和迭代器输出，会破坏顺序结构 Deque在队列的基础上，添加了对两端进行操作的方法。即, Last与Frist 工具类java.util.Collections Collections.emptyList() Collections.emptySet() Collections.emptyMap();创建空集合 Collections.shuffle() 洗牌 打乱顺序 3.List list = Collections.unmodifiableXXX(xxx);把对应集合封装成不可变集合xxx为原型，原型可变；若原型添加元素，则不可变集合也对应改变。所以，在转换为不可变集合过后，立即将原型给扔掉。","link":"/2019/11/20/Java 集合Vector、Stack、HashTable等/"},{"title":"Java内部类","text":"示例1234567891011121314151617181920212223242526public class Outer{ int i = 1; public void show(){ System.out.println(\"Outer.show()\"); } class Inner{ int a = 111; public void print(){ System.out.println(\"Inner.print()\"); } } public static void main(String[] args){ Outer out = new Outer(); int i = out.i; out.show(); Outer.Inner in = out.new Inner(); int a = in.a; in.print(); }} 内部类作用","link":"/2019/10/29/Java内部类/"},{"title":"JSP(Java Server Page)","text":"Tomcat进入到JavaEE阶段，将项目部署到Tomcat服务器上使用户能够访问到。 Apache Tomcat下载官网：https://tomcat.apache.org/测试安装是否成功：http://localhost:8080 Tomcat项目结构 binconfliblogstempwebappswork 3.本地应用程序资源 D:\\Program Files\\Java\\jdk1.8.0_201\\jre.exe网络应用程序资源 URL http://localhost:8080/webproject/123.html http://127.0.0.1:8080/webproject/123.html 本地Tomcat D:\\Program Files\\apache-tomcat-8.5.40\\webapps网络访问Tomcat http://localhost:8080/webproject/123.html 网络请求顺序1.通过http发起请求 网络访问Tomcat http://localhost:8080/webproject/123.html 网络访问通过socket请求获取网页的源代码2.1 inputStream以字节的形式读取网页的源代码2.2 outputStream以字节的形式输出网页的源代码（响应相关的请求 通过http发起响应） 浏览器接收服务器（Tomcat）以字节的形式输出的网页的源代码，并解析。 常见Http协议请求状态码:200 成功的状态码500 页面有错误404 无效的URL304 有效的URL 开始搭建WEB项目JSP (Java Server Page)搭建了一个JSP的简单WEB项目 将部分Java代码（逻辑处理）分离出来 1 在项目目录下 创建 WEB-INF 目录 2 在 WEB-INF 目录下 创建 classes 目录 3 在 classes 目录下 创建Java类包 项目中Java类包的命名，约定，www.baidui.com com/baidu/ com/项目的名字 4 将分离后的Java类方入包中，并进行编译，获取对应的.class文件 5 逻辑代码分离后，需要重启Tomcat JSP中的对象是怎么生成的（例如：请求对象 request 输出的对象 out） 每一个JSP文件，再第一次访问的时候，都会被Tomcat自动编译为一个对应的java文件这个java文件中最核心的方法 就是 _jspService() 在work目录查找，并对比","link":"/2019/12/16/JavaEE之JSP/"},{"title":"Java异常","text":"Java异常的捕获与处理1234567try{ //可能含有异常的语句块}catch(Exception e){ //捕获了异常后的处理语句块}finally{ //最终执行代码}","link":"/2019/11/12/Java异常/"},{"title":"Java多线程","text":"基本概述 多任务处理有两种类型：基于线程、基于进程 进程一种”自包容”的运行程序，有自己的内存地址，线程是进程的一个顺序控制流。 即，一个线程中有一段自上而下的程序。 一个进程中至少有一个线程。 基于进程的特点是允许计算机同时处理两个或更多的程序 线程的理解假设一个cpu，只有一核一线程，某一时刻只能执行一个线程。如果要执行10个线程，那么10线程将交叉执行。感觉10个线程在同时的运行。 线程的创建 继承Thread创建线程 1234567public class ThreadTest01 extends Thread{ //重写覆盖该方法 //在方法体中写 我们想要通过线程执行的程序 public void run(){ }} 实现Runnable创建线程 12345public class ThreadTest02 implements Runnable{ public void run(){ }} 线程的使用1234567891011121314151617181920public class Thread01 extends Thread{ public void run(){ for(int i = 0; i &lt; 5; i ++){ System.out.println(\"Thread01 - \" + i); } } public static void main(String[] args){ Thread01 thread01_1 = new Thread01(); thread01_1.start(); for(int i =0; i &lt; 5; i ++){ System.out.println(\"thread_main\" + \" - \" + i); } }}/* * 只有通过start()方法才是启动一个线程(子线程) * */ 1234567891011121314151617public class Thread02 implements Runable{ public void run(){ for(int i = 0; i &lt; 5; i ++){ System.out.println(\"Thread02 - \" + i); } } public static void main(String[] args){ Thread02 thread02 = new Thread02(); Thread thread = new Thread(thread02); thread.start(); for(int i = 0; i &lt; 5; i ++){ System.out.println(\"MainThread - \" + i) } }} 多线程的使用场景 开发中多线程的意义？(什么场景下使用多线程) 页面显示中，页面的显示和取数据分为两个线程执行。 类似于：早上起来，在烧开水的同时洗脸刷牙。 开发中如何使用 线程三种创建方式的优劣针对于多个线程做同一件事情，使用实现Runnable接口的方式创建线程针对于多个线程做不同的事情，则使用继承Thread对象的方式创建线程 线程的优先级 线程的默认优先级为5 线程的优先级最高为10， 最低为0。 线程的生命周期 初始状态 --> 就绪状态 --> 运行状态 --> 死亡状态 线程常用的静态方法 sleep(): 使线程睡眠一段时间后，在执行。 join(): 使当前线程执行完过后，再执行其他的线程。 线程让步-yield():作用：暂停当前正在运行的线程，并执行其他线程。(可能没有效果)详解：让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中yield()无法保证达到目的，因此让步线程可能被CPU的线程调度器再次选中。 wait(): 使线程进入永远睡眠的状态，其他线程使用notify()、notifyAll()来唤醒睡眠线程。--&gt; 生产者-消费者模式 1234567891011121314151617181920public class Producer extends Thread{ private String name; pricate Storage storage; public void run(){ while(true){ try{ storage.add(name); }catch(InterruptedException e){ } try{ Thread.sleep(1000); }catch(InterruptedException e){ } } }} 123456789101112131415161718192021public class Storage{ private int count; private int size; public Storage{ } publoc Storage(int s){ this.size = s; } public synchronized void add(String name) throws InterruptedException{ if(count == size){ this.notify(); this.wait(); } } public synchronized void delete(String name) throws InterruptedException{ }} 线程同步锁123456789101112131415161718192021public class ThreadTest implements Runnable{ private Test temp; ThreadTest(Test temp){ this.temp = temp; } public void run(){ synchronized(this){ temp.sale(); //需要同步的代码块 } } }class Test{ public void sale(){ for(int i = 0; i &lt; 10; i ++) System.out.println(i); }} 使用Executor 使用CachedThreadPool执行线程 123456789101112131415public class ThreadTest implements{ public void run(){ } public static void main(String[] args){ ExecutorService exec = Executors.newCachedThreadPool(); for(int i = 0; i &lt; 5; i ++){ exec.execute(new ThreadTest()); } //shutdown()方法的调用防止新任务被提交到exec对象当中 //当前main线程将继续运行shutdown()方法调用之前的所有任务 exec.shutdown(); }} 使用FixeldThreadPool执行线程在FixedThreadPool对象实例的ExecutorService对象中，可以规定同时执行的线程数量。如果，规定有3个线程同时运行，但是有五个线程任务，那么将先执行三个线程，完成一个之后，后面的线程加入进来。 12345678910public class FixedThreadPool implements Runnable{ public void run(){} public static void main(String[] args){ ExecutorService exec = Executors.newFixedThreadPool(5); for(int i = 0; i &lt; 5; i ++) exec.execute(new FixedThreadPool)； exec.shutdown(); }} 使用SingleThreadExecutor执行线程SingleThreadExecutor相当于Executors.newFixedThreadPool(1)获取的执行器对象该对象的内部拥有一个按照加入的任务顺序的一个队列，并且按照队列顺序执行。 1234567891011public class SingleThreadTest implements Runnable{ public void run(){} public static void main(String[] args){ ExecutorService exec = Executors.newSingleThreadExecutor(); for(int i = 0; i &lt; 10; i ++){ exec.execute(new SingleThreadTest()); } exec.shutdown(); }} 线程任务中产生返回值 简述: Runnable接口是执行工作的独立任务，不具有返回值。如果期待任务完成后拥有一个返回值，那么可以实现Callable接口而不是Runnable接口，使用ExecutorService.submit()调用。 123456789101112131415161718192021222324252627282930313233public class TaskWithResult implements Callable&lt;String&gt;{ private int id; public TaskWithResult(int id){ this.id = id; } public String call(){ return \"result of TaskWithResult \" + id; } public static void main(String[] args){ ExecutorService exec = Executors.newCacheThreadPool(); ArrayList&lt;Future&lt;String&gt;&gt; results = new ArrayList&lt;Future&lt;String&gt;&gt;(); for(int i = 0; i &lt; 10; i ++){ //exec.submit()方法返回的是一个Future&lt;String&gt;泛型对象 具体类型为任务类中实现是的具体类型 results.add(exec.submit(new TaskWithResult(i))); } for(Future&lt;String&gt; fs: results){ try{ System.out.println(fs.get); }catch(InterruptedException e1){ System.out.println(e1); return; }catch(ExecutionException e2){ System.out.println(e2); return; }finally{ exec.shutdown(); } } }} 线程的休眠 简述，有时使用Thread.sleep()方法使多个线程休眠的时候，将呈现顺序的完美分布的状态，但这种状态有时是依赖底层的线程处理机制的，如果需要呈现“完美的分布”的顺序执行，那么采用线程的同步运行机制是最好的。 线程的优先级线程的优先级是将线程的重要性传递给调度器，优先级的高低只是CPU的调度器调度的频率的不同，而不是优先级高的一直执行，优先级低的一直得不到执行。举个栗子： 12345678910111213141516171819202122232425262728293031323334public class SimplePriorities implements Runnable{ private int countDown = 5; private volatile double d; private int priority; public SimplePriorities(int priority){ this.priority = priority; } public String toString(){ return Thread.currentThread() + \":\" + countDown; } public void run(){ Thread.currentThread().setPriorities(priority); while(true){ for(int i = 1; i &lt; 100000; i ++){ d += (Math.PI + Math.E) / (double)i; if(i % 1000 == 0) Thread.yield(); } System.out.println(this); if(--countDown == 0) return; } } public static void main(String[] args){ ExecutorService exec = Executors.newCachedThreadPool(); for(int i = 0; i &lt; 5; i ++){ exec.execute(new SimplePriorities(Thread.MIN_PRIORITY)); exec.execute(new SimplePriorities(Thread.MAX_PRIORITY)); } exec.shutdown(); }} 后台线程后台线程不属于程序不可或缺的一部分，它依赖于非后台线程(main就是一个非后台线程)，当所有非后台线程结束时，所有的后台线程也将终止。 显示的创建后台进程 123456789101112131415161718192021222324252627public class SimpleDaemons implements Runnable{ public void run(){ try{ while(true){ TimeUnit.MILLISCONEDS.sleep(100); System.out.println(Thread.currentThread() + \" \" + this); } }catch(InterruptedException e){ System.out.println(sleep() interrupted); } } public static void main(String[] args){ for(int i = 0; i &lt; 10; i ++){ Thread daemon = new Thread(new SimpleDaemons()); // 通过setDaemon(boolean)方法设置线程为后台线程 //且该设置必须在调用start()之前 daemon.setDaemon(true); daemon.start(); } System.out.println(\"All Daemon started\"); //通过sleep方法设置主线程的睡眠时间为175毫秒，给后台线程的足够的时间运行 //如果设置睡眠时间小于100毫秒，则后台线程没有足够的运行时间输出输出语句 //如果设置睡眠时间等于100毫秒，则后台线程有0-10个线程有可能输出输出语句 TimeUnit.MILLSCONEDS.sleep(175); }} 通过编写定制的ThreadFactory可以定制Executor创建的线程的属性(后台，优先级， 名称) 1234567891011121314151617181920212223242526public class DaemonFormFactory implements Runnable{ public Thread newThread(Runnable r){ Thread thread = new Thread(r); thread.setDaemon(true); return thread; } public void run(){ try{ while(true){ TimeUnit.MillSCONEDS.sleep(100); System.out.println(Thread.currentThread() + \" \" + this); } }catch(InterruptedException e){ System.out.println(\"Interrupted\"); } } public static void main(String[] args){ ExecutorService exec = Executors.newCachedThreadPool(new DaemonFactory()); for(int i = 0; i &lt; 10; i ++) exec.execute(new DaemonFormFactory()); System.out.println(\"All daemons started.\"); TimeUnit.MILLSCONEDS.sleep(500); }} 如果一个线程是后台线程，那么该线程所构建的子线程也是一个后台线程。 捕获异常 引子由于线程的本质，你不能捕获从线程中逃逸的异常，一但线程逃出了任务的run()方法,它就会马上发送到控制台，除非使用特殊的方式捕获。例如，以下的捕获异常代码块永远都得不到执行 12345678910111213141516171819202122232425public class ExceptionThread implements Runnable{ public void run(){ throw new RuntimeException(); } public static void main(String[] args){ try{ ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new ExeceptionThread); }catch(RuntimeException e){ //This statement will not execute. System.out.println(\"Exception has been handled!\") } }}/* Output * java.lang.RuntimeException * at ExceptionThread.run(ExceptionThread.java:7) * at ThreadPoolExecutor&amp;Worker.runTask(Unknown Source) * at ThreadPoolExecutor&amp;Worker.run(Unknown Source) * at java.lang.Thread.run(Unknown Source) * * 过程为ExceptionThread.run()执行完，马上抛出异常后控制台输出，线程死亡，即，当catch捕获时线程中的异常已经逃逸 */ 采用Thread.UncaughtExceptionHandler.uncaughtException()处理没被抓取的异常 1234567891011121314151617181920212223242526272829303132333435363738394041class ExceptionThread2 implements Runnable{ public void run(){ Thread t = Thread.currentThread(); System.out.println(\"run() by \" + t); System.out.println(\"eh = \" + t.getUncaughtExceptionHandler()); throw new RuntimeException(); }}class MyUncaughtExceptionHandlder implements Thread.UncaughtExceptionHandler{ public void uncaughtException(Thread r, Throwable e){ System.out.println(\"caught \" + e); }}class HandlerThreadFactory implements ThreadFactory{ public Thread newThread(Runnable r){ System.out.println(this + \" creating new Thread\"); Thread t = new Thread(r); System.out.println(\"created \" + t); t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler()); System.out.println(\"eh = \" + t.getUncaughtExceptionHandle()); return t; }}public class CaptureUncaughtException{ public static void main(String[] agrs){ ExecutorService exec = Executors.newCachedThreadPool(new HandlerThreadFactory()); exec.execute(new ExceptionThread2()); }}/* Output: * HandlerThreadFactory@de6ced creating new Thread * created Thread[Thread-0, 5, main] * eh = MyUncaughtExceptionHandler@1fb8ee3 * run() by Thread[Thread-0, 5, main] * eh = MyUncaughtExceptionHander@1fb8ee3 * caught java.lang.RuntimeException */ 可以看出线程是在工厂中设置未捕获异常处理器来处理异常，处理器通过实现Thread.UncaughtExceptionHandler接口处理，","link":"/2019/11/18/Java多线程/"},{"title":"Java控制语句","text":"一、有三种情况可以改变程序顺序执行1.选择语句-&gt; 分支语句 -&gt;分支结构 2.循环语句 3.方法调用二、Java表达式表达式是由变量或常量与符号的组合，表达式的符号称为运算符,变量或常量称为操作数。 三、Java if语句1.单分支语句(if…)123456int password = 666;if(password == 666){ System.out.println(\"恭喜你登录成功\");}else{ System.out.println(\"密码错误,登录失败！\");} 依次输入三个整数, 判断输出最大的数 12345678910111213141516171819public static void printMaxNum() { System.out.println(\"请输入第一个整数\"); Scanner scan = new Scanner(System.in); int num1 = scan.nextInt(); System.out.println(\"请输入第二个整数\"); int num2 = scan.nextInt(); System.out.println(\"请输入第三个整数\"); int num3 = scan.nextInt(); int max = num1; if (num2 &gt;= max) max = num2; if(num3 &gt;= max) max = num3; System.out.println(max);} 2.双分支if语句(if…else…) if只有当条件满足(true)的时候才会执行if语句块里面的代码 else语句一定不能有条件 if语句可以单独存在，else语句不能单独存在 else语句只能出现一次(一个if，一个else) 3.多分支if语句(if…esle if…)12345678910111213public static void checkScore(){ int score = 100; if(score &gt;= 90) System.out.println(\"优\"); else if(score &gt;= 80) System.out.println(\"优\"); else if(score &gt;= 70) System.out.println(\"优\"); else if(score &gt;= 60) System.out.println(\"优\"); else System.out.println(\"\");} 四、Switch语句Switch 语句有如下规则 switch语句中的变量类型只能为byte、short、int、char、String。 switch语句可以拥有多个case语句。 每个case后面跟一个要比较的值和冒号。 case语句中的值的数据类型和变量的数据类型相同，而且只能是常数或者字面常量。 每个case常量的值必须或不相同。 当变量的值与case语句的值相等时，那么case语句之后的语句开始执行。 当遇到break语句时，switch语句终止，程序跳到switch语句后面的语句执行。break语句为可选项，如果没有break语句出现，程序会继续执行下面一条case语句，直到case结束。 switch语句可以包含一个default分支，该分支必须时switch语句的最后一个分支。default分支在所有的case语句的值和变量值比较失败时执行，default分支不需要break语句。 五、练习题按年/月/日的顺序输入一个任意日期，在页面输出：这是这一年的第几天如: 2016年1月2日是2016年的第2天，而2016年12月31日则是2016年的第366天 12345678910111213141516171819202122232425262728293031323334public static void printDays() { System.out.println(\"请按年/月/日的顺序输入一个任意日期!\"); Scanner scan = new Scanner(System.in); System.out.println(\"请输入年: \"); int y = scan.nextInt(); System.out.println(\"请输入月: \"); int m = scan.nextInt(); System.out.println(\"请输入日: \"); int d = scan.nextInt(); int days = 0; boolean leap = (y % 4 == 0 &amp;&amp; y % 100 != 0 || y % 400 ==0) ? true : false; switch(m) { case 12: days += 30; case 11: days += 31; case 10: days += 30; case 9: days += 31; case 8: days += 31; case 7: days += 30; case 6: days += 31; case 5: days += 30; case 4: days += 31; case 3: days += leap ? 29 : 28; case 2: days += 31; case 1: days += d;break; default: System.out.println(\"您输入的月份有误！\"); } System.out.println(y + \"年\" + m + \"月\" + d +\"日\" +\"是\" + (leap? \"闰年\" : \"平年\") + \",是\" + y + \"的第\" + days + \"天\"); scan.close();} 用户输入整数。如果输入的是1～6 的整数，则程序输出:your number is in 1～6. c=（用户输入的数）如果输入的是其它数字，输出:Your number is too large/small. c=（用户输入的数） 12345678910public static void printNum(){ System.out.println(\"请输入1-6的整数: \"); Scanner scan = new Scanner(System.in); int num = scan.nextInt(); String str = \"Your number is \" + (num &gt;= 1 &amp;&amp; num &lt;= 6 ? \"in 1-6.\" : \"to large/small.\") + \"c = \" + num; System.out.println(str); scan.close();} 编写代码:按照输入的路程计算运费，计算规则如下：运输公司对用户计算运费.路程越远每公里运费越低。每公里每吨货物的基本运费为10,货物重量为w,距离为s,折扣为d,则总运费f的计算公式为：f=10ws*(1-d) s&lt;250km 没有折扣 250&lt;=s&lt;500 2%折扣 500&lt;=s&lt;1000 5%折扣 1000&lt;=s&lt;2000 8%折扣 2000&lt;=s&lt;3000 10%折扣 3000&lt;=s 15%折扣 12345678910111213141516171819202122public static void freight() { System.out.println(\"请输入路程: \"); Scanner scan = new Scanner(System.in); int s = scan.nextInt(); double discount; if(s &lt; 250) discount = 0; else if(s &lt; 500) discount = 0.02; else if(s &lt; 1000) discount = 0.05; else if(s &lt; 2000) discount = 0.08; else if(s &lt; 3000) discount = 0.1; else discount = 0.15; System.out.println(\"总运费为: \" + 10d * (double)s * (1d - discount) + \"w\"); scan.close();} 模拟自动饮料机，输入操作码 1.当为输入0时，模拟自动饮料机停止运行 2.自动饮料机运行的过程中， 当输入1-5时候给出对应的饮料(1.可口可乐 2.雪碧 3.鲜橙多 4.冰红茶 5.矿泉水) 3.输入其他值的时候给出非法操作提示，并提示重新输入 1234567891011121314151617public static void sellDrinks() { System.out.println(\"please input operation code: \"); Scanner scan = new Scanner(System.in); int code = 0; code = scan.nextInt(); switch(code) { case 0 : System.out.println(\"exiting...\");break; case 1 : System.out.println(\"可口可乐\");break; case 2 : System.out.println(\"雪碧\");break; case 3 : System.out.println(\"鲜橙多\");break; case 4 : System.out.println(\"冰红茶\");break; case 5 : System.out.println(\"矿泉水\");break; default: System.out.println(\"Error:illegal operation. please input again.\"); } scan.close();} 水仙花数 例：水仙花数 153=111+555+333 输入一个数，判断是不是水仙花数 1234567891011121314public static void narcissisticNumber() { System.out.println(\"请输入一个数字: \"); Scanner scan = new Scanner(System.in); int num = scan.nextInt(); int one = num / 100; int two = num / 10 % 10; int three = num % 10; boolean isNarcissisticNumber = (one * one * one + two * two * two + three * three * three) == num; System.out.println(\"您输入的这个数字\" + num + (isNarcissisticNumber ? \"\" : \"不\") +\"是一个水仙花数\"); scan.close();}","link":"/2019/10/15/Java控制语句/"},{"title":"Java循环语句","text":"一.什么是循环语句？顺序结构的程序就只能被执行一次。如果想要同样的操作执行多次，就需要循环结构。二.while语句(先验循环)直接上代码 123456789while(true){ System.out.println(\"Hello World!\");}/* Output * Hello World! * Hello World! * ............. * 无限输出Hello World */ 控制循环的次数 123456789101112int count = 0;while(count &lt; 10){ System.out.println(\"Hello World\"); count ++;}/* Output * Hello World! * Hello World! * ............. * 输出10次 Hello World */ 练习一下, 随机生成一个[1,5)的整型数, 使用while循环猜测这个数字是多少, 直到猜对退出。 1234567891011121314151617public static void guessNum() { System.out.println(\"请输入一个你猜测的数字: \"); Scanner scanner = new Scanner(System.in); int num = new Random().nextInt(5); int guess; while(true) { guess = scanner.nextInt(); if(guess == num) { System.out.println(\"恭喜你, 猜对了！ 数字为 \" + num); System.out.println(\"正在退出......\"); break; }else { System.out.println(\"抱歉, 你猜\" + (guess &gt; num ? \"大\" : \"小\") + \"了, 请重新输入: \"); } } scanner.close();} 扩展上一题, 有三次猜测的机会, 如果三次都没有猜成功, 则强制退出。 1234567891011121314151617181920public static void guessNum3time() { System.out.println(\"输入一个数: \"); Scanner scanner = new Scanner(System.in); int num = new Random().nextInt(5); int count = 0, guess; while(3 &gt; count) { guess = scanner.nextInt(); if(guess == num) { System.out.println(\"恭喜你, 猜对了！ 数字为 \" + num); System.out.println(\"正在退出......\"); break; }else { if(3 == ++ count) System.out.println(\"三次机会已用完, 正在退出......\"); else System.out.println(\"抱歉, 你猜\" + (guess &gt; num ? \"大\" : \"小\") + \"了, 请重新输入: \"); } } scanner.close();} do…while…语句(后验循环)先执行一次循环，后验证是否执行循环 12345678do{ System.out.println(\"Hello World\");}while (false);/* * Output: * Hello World */ 使用do…while输出0-50以内所有能被7整除的数 12345678910111213public static void divide7() { final int MAX_NUM = 50; int num = 0; boolean action = true; do { num ++; if(num % 7 == 0) System.out.println(\"0-50以内\" + num + \"能被7整除\"); action = num &lt; MAX_NUM; }while (action);} for循环for循环是循环结构中使用最广泛的一种循环控制语句for循环格式: 表达式1 表达式2 表达式3 初始化 布尔表达式 自增/自减表达式- for(表达式1; 表达式2; 表达式3){ 循环体} 123for (; true; ){ System.out.println(\"Hello World\")} 使用for输出0-9 12345public static void print0_9(){ for(int i = 0; i &lt; 10; i ++) { System.out.println(i); }} break与continue break: 应用范围:选择结构Switch和循环结构 作用: 用于跳出循环, 用到此关键字，跳出对应循环 continue 作用范围: 只用在循环结构 作用: continue的作用是跳过本次循环步骤中余下尚未执行语句,然后进行循环的自增或自减条件练习题1、读入一个小于10的整数n，输出它的阶乘12345678910111213141516171819202122public static void factorial() { System.out.println(\"请输入一个小于10的整数: \"); Scanner scan = new Scanner(System.in); int num = 0; boolean isLegal = true; do { num = scan.nextInt(); isLegal = 1 &lt;= num &amp;&amp; 10 &gt; num; if(!isLegal) System.out.println(\"你输入的数字不合法, 请重新输入: \"); } while (!isLegal); scan.close(); int product = 1; for(int i = 1; i &lt;= num; i ++) { product *= i; } System.out.println(product);} 2、猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想再吃时，只剩下一个桃子了。求第一天共摘了多少。 123456789101112131415161718public static void eatPeach() { int all = 1; for(int day = 9; day &gt; 0; day --) { all = (all + 1) * 2; } System.out.println(\"第一天共摘了\" + all + \"个\"); // 1 1534 // 2 766 // 3 382 // 4 190 // 5 94 // 6 46 // 7 22 // 8 10 // 9 4 // 10 1} 3、找出100–999里面有多少个水仙花数，分别输出这些水仙花数？ 123456789101112131415161718192021public static void getNNIn100_999() { int count = 0; String nums = \"\"; for(int i = 100; i &lt;= 999; i++) { int one = i / 100; int two = i / 10 % 10; int three = i % 10; boolean isNN = i == one * one * one + two * two * two + three * three * three; if(isNN) { count ++; nums += i + \"\\t\"; } } System.out.println(\"100-999里面共有\" + count + \"个水仙花数, 分别是\\t\" + nums);}/* * Output: * 100-999里面共有4个水仙花数, 分别是 153 370 371 407 */ 4、小球从100米掉落，弹起到50米，然后再掉落，弹到25米，弹10次以后， 小球经过的路径是多少米，以及第10次弹地高度 1234567891011121314151617public static void getPathLength() { double pathLength = 0; double height = 100; for(int i = 0; i &lt; 10; i ++) { pathLength += height; height /= 2; pathLength += height; } System.out.println(\"10次以后,小球经过的路径是\" + pathLength + \"米，第10次高度为\" + height + \"米\");}/* * Output: * 10次以后,小球经过的路径是299.70703125米，第10次高度为0.09765625米 */ 5、1，1，2，3，5，8，13. 找出第20个数是多少？ 得出前20个数之和是多少 ? 123456789101112131415161718public static void getNo20() { int preOne = 1, preTwo = 1; int num = 0; int sum = preOne + preTwo; for(int i = 3; i &lt;= 20; i ++) { num = preOne + preTwo; preTwo = preOne; preOne = num; sum += num; if(i == 20) System.out.println(\"第20个数是\" + num + \", 前20个数之和为\" + sum); }}/* * Output: * 第20个数是6765, 前20个数之和为17710 */","link":"/2019/10/16/Java循环语句/"},{"title":"Java循环语句Plus(多重循环)","text":"九九乘法表正序 123456789101112131415161718for(int i = 1; i &lt; 10; i ++) { for(int j = 1; j &lt; 10; j++) { if(i &gt;= j) System.out.print(i + \"*\" + j + \"=\" + i * j + (i * j &gt;= 10 ? \" \" : \" \")); } System.out.println();}/* Output * 1*1=1 * 2*1=2 2*2=4 * 3*1=3 3*2=6 3*3=9 * 4*1=4 4*2=8 4*3=12 4*4=16 * 5*1=5 5*2=10 5*3=15 5*4=20 5*5=25 * 6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 * 7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 * 8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 * 9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81 */ 反序 1234567891011121314151617181920212223242526272829303132for(int i = 9; i &gt; 0; i --) { int num = i; for(int j = 9; j &gt; 0; j --) { if(num &gt; 0) System.out.print(j + \"*\" + num + \"=\" + j * num + (j * num &gt;= 10 ? \" \" : \" \")); num --; } System.out.println();}/* Output: * 9*9=81 8*8=64 7*7=49 6*6=36 5*5=25 4*4=16 3*3=9 2*2=4 1*1=1 * 9*8=72 8*7=56 7*6=42 6*5=30 5*4=20 4*3=12 3*2=6 2*1=2 * 9*7=63 8*6=48 7*5=35 6*4=24 5*3=15 4*2=8 3*1=3 * 9*6=54 8*5=40 7*4=28 6*3=18 5*2=10 4*1=4 * 9*5=45 8*4=32 7*3=21 6*2=12 5*1=5 * 9*4=36 8*3=24 7*2=14 6*1=6 * 9*3=27 8*2=16 7*1=7 * 9*2=18 8*1=8 * 9*1=9 */``` #### break flag给循环体加一个标签,break后面跟flag名字,则退出标记的循环```javaflag01:for(int i = 0; i &lt; 3; i ++){ flag02:for(int j = 0; j &lt; 3; j ++){ if(i == 1){ break flag01; } }} 输出图案123456789101112131415161718192021public static void printStar() { for(int i = 1; i &lt;= 9; i ++) { for(int j = i,line = 9; j &lt;= 9; j ++) { System.out.print(\"*\"); if(i &lt; 5 &amp;&amp; i + line-- == 10) break; } System.out.println(); }}/* * * * ** * *** * **** * ***** * **** * *** * ** * * */ 练习题 “百钱买百鸡”是我国古代的著名数学题。3文钱可以买1只公鸡，2文钱可以买1只母鸡，1文钱可以买3只小鸡。用100文钱买100只鸡，那么各有公鸡、母鸡、小鸡多少只？ 12345678910111213141516public static void buyChicken() { for(int male = 1; male &lt; 100/3; male ++) { for(int kid = 3; kid &lt;= 97; kid += 3){ int female = 100 - male - kid; if(100 == 3 * male + 2 * female + kid/3 &amp;&amp; female &gt; 0) System.out.println(\"公鸡:\" + male + \"\\t母鸡:\" + female + \"\\t小鸡\" + kid); } } }/* Output: * * 公鸡:5 母鸡:32 小鸡63 * 公鸡:10 母鸡:24 小鸡66 * 公鸡:15 母鸡:16 小鸡69 * 公鸡:20 母鸡:8 小鸡72 */ 搬砖问题：36 块砖， 36 人搬，男搬4，女搬3，2小孩抬1砖，要求一次全搬完，问男、女和小孩各多少人？ 12345678910111213public static void moveBrick() { for(int man = 1; man &lt; 36/4; man ++) { for(int kid = 2; kid &lt;= 34; kid += 2) { int woman = 36 - man - kid; if(36 == 4 * man + 3 * woman + kid/2 &amp;&amp; 0 &lt; woman) System.out.println(\"男人:\" + man + \"\\t女人:\" + woman + \"\\t孩子:\" + kid); } } }/* Output: * * 男人:3 女人:3 孩子:30 */","link":"/2019/10/17/Java循环语句Plus(多重循环)/"},{"title":"Java类的加载、连接、初始化...","text":"Java类的加载类的生命周期包含了加载、验证、准备、解析、初始化、使用、卸载七个步骤，其中验证、准备和解析可以合并为一步叫做连接。 加载：Java虚拟机查找字节流文件，并根据字节流创建java.lang.Class对象的过程。在此过程中将类型的.class文件中的二进制数据读入内存，放在运行时区域的方法区内。然后在堆中创建java.lang.Class对象，用来封装类在方法区的数据类型。 连接：包裹验证、准备以及解析三个阶段。 验证阶段。主要的目的是确保背加载的类满足 初始化 初始化：标记为常用值的字段赋值的过程。只对static修饰的变量或语句块进行初始化。 如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。 如果同时包含多个静态变量和静态方法，预先加载静态代码块。 对于一个类，执行顺序如下 静态代码块构造代码块构造函数 对于有继承的情况下，执行顺序如下 父类静态代码块子类静态代码块父类构造代码块父类构造方法子类构造代码块子类构造方法 Java的类加载器 根类加载器(BootStrapClassLoader)–&gt;底层是C语言 主要负责加载jre/lib/rt.jar相关字节码文件 扩展加载器(ExtensionClassLoader) 主要负责加载(jre/lib/ext/*.jar)其父类输出是null, 但是BootStrapClassLoader为最高父类，由于底层是C++写的，因此Java找不到该加载器 应用程序加载器(ApplicationClassLoader) 父类ExtendsionClassLoader 主要负责用户自定义classpath路径下所配置的jar包 自定义加载器(UserClassLoader) 加载器的选择双亲委托：AppcClassLoader首先加载，但是会先询问ExtCalssLoader类加载器是否加载，如果Ext加载了，app就不加载了，反之app加载。ext加载以前，也同样询问Bootstrap是否加载…如果类加载器收到了类加载器的请求，那么会将这个请求一层一层的传递到父加载器中，当父加载器反馈自己不能加载的时候，才自己加载。 JVM加载机制主要有三种 全盘加载。当一个类加载的时候，默认会将该类中所依赖的所有.class一起加载 缓存机制。所有加载过的.class文件都会被放入缓存，下次使用该.class文件时，JVM会优先从缓存中查找，如果没有，才会去加载指定的字节码文件，这也是为什么当字节码文件变化后，需要重启JVM才能够看到修过效果的原因 Class类及其方法12345678910111213Calss clazz = Student.class;//获取public修饰的属性，及其父类的属性Field field = clazz.getField(\"FieldName\");//获取声明的该类属性Field dfield = clazz.getDeclaredField(\"FieldName\");//获取该类与父类public属性的数组Field[] fields = clazz.getFields();//获取....Field[] dfields = clazz.getDeclaredField(); Field类及其方法123456789Class clazz = Student.class;//返回字段名称clazz.getName();//返回字段类型clazz.getType();// 返回字段的修饰符，是一个int型，不同的bit表示不同的含义clazz.getModifiers();","link":"/2019/12/02/Java类的加载、连接、初始化.../"},{"title":"Java数组高级用法","text":"引用类型的一维数组","link":"/2019/10/23/Java数组高级用法/"},{"title":"Java继承","text":"Java继承继承关键字: extends字类继承父类非private修饰的属性和方法java中只能单一继承, 一个子类只能有一个父类,但可以多重继承子类继承父类的属性 方法， 但没有继承构造方法(构造方法第一行super()))子类调用父类的构造方法用super(成员变量),调用方法和属性用super.字段/方法子类可以在父类属性和方法进行扩展,属性方法的调用采用就近原则。优点:减少重复代码 缺点:代码耦合 父类 123456789public class Father{ String skinColor = \"yellow\"; String eyeColor = \"black\"; public void walk(){ System.out.println(\"--直立行走\"); }} 子类 123public class kid extends Father{} Java继承缺省1. 由于每个类继承于Object, 默认import java.lang.*2. 每个类有一个默认的无参构造方法3. 每个构造方法第一行默认Super()调用父类构造方法4. 默认的 类访问修饰符(package)5. void返回值 默认return6. 每个类默认extends Object7. private访问修饰符的方法默认被final修饰8. final修饰的类 的方法默认被final修饰 final关键字 final关键字 修饰的类不允许被继承 final关键字 修饰的变量不能被修改 final关键字 修饰的方法不能被重写 重写当子类重写父类的方法时, 必须遵守如下规则:1. 访问修饰符的开放性必须大于父类的访问修饰符。 · 如果父类方法是public，那么子类必须是public · 如果父类方法是protected，那么子类必须是protected或public2. 子类的方法返回值的类型 必须和父类的相同或者是子类类型3. 子类的方法的方法名和形式参数列表，必须和父类中的是相同的(参数个数，类型，顺序)4. 子类中重写的异常不能抛出比父类更多的异常 封装1. 修改属性的可见性来限制对属性的访问(一般限制为private)2. 对每个private的属性提供对外的公共方法访问，也就是创建一对赋值/取值方法，间接访问属性对于一个只有私有属性和针对私有属性的公共get/set方法。我们称之为JavaBean 封装的好处1. 类的成员变量可以成为只读或者只写的2. 类可以控制其成员变量中的值，有一个整体的控制3. 封装可以被认为一个保护屏障，防止类的代码和数据被外部类定义代码随机访问和修改 变量1. 只有static修饰的变量叫做静态变量2. public+static 修饰的变量-全局变量3. 成员变量（定义在类的语句块中）4. 局部变量（定义在方法的语句块中，或方法的形式参数中）5. 普通方法中可访问静态变量，但是在静态方法中不可以访问非静态的变量 初始化顺序静态变量-&gt;静态初始化块-&gt;静态方法-&gt;super()-&gt;成员变量-&gt;初始化块-&gt;构造方法-&gt;方法 123456789101112131415161718192021222324252627282930public class Test{ //静态变量 在类加载器加载的时候被定义 public static int i; //成员变量 在构造方法缺省super()之后加载 //--构造方法super() &gt; 成员变量 &gt; 初始化块 &gt; 构造方法super()之后 public int j; //静态初始化块 在类加载器加载的时候初始化----- 静态变量 &gt; 静态初始化块 static{ i = 6; } //初始化块 在构造方法缺省super()之后加载 { j = 12; } //静态方法 再类加载器加载的时候初始化----静态初始化块 &gt; 静态方法 public static int getI(){ return i; } public Test(){ super(); System.out.println(\"在初始化块之后运行\"); }} 总结 私有属性private加get/set 与 公共属性有什么区别？ 私有属性被封装 隐藏了对外细节; 通过get/set方法进行赋值与取值, 可以对数据进行相应处理,保护数据安全。 公共属性，访问级别为public，都能通过对象访问和修改该属性。 变量生命周期 成员变量:在类的内部，本类的语句块中，离开了类需要用类的对象来访问 局部变量:在方法的内部，方法的语句块中。 全局变量:在程序的任意位置，用类名调用。 静态变量:在同包的任意位置，用类名调用。 静态变量、静态方法、普通方法在使用中需要注意的点？ 静态方法不能访问非静态变量 非静态方法可以访问静态成员 什么时候必须使用静态初始化块(静态实例化块)？ 当静态方法访问静态变量，而静态变量需要默认值的时候？ 以下Javac编译后 字节码文件名为多少？ 1234567public class Test {}class temp{} Test.class与temp.class 123456public class Test { class temp{ }} Test.class与Test$temp.class","link":"/2019/10/24/Java继承/"},{"title":"Java数组","text":"Java数组编程语言中最重要的数据结构之一什么是数组？ 数组是存储在一个连续的内存块中的元素集合。 数组中的每个元素必须是相同的类型，并且通过索引区分。数组中的第一个元素索引为0。 为什么用数组？ 单一的类型变量有时候很难满足应用程序的设计要求。 数组类型变量可以同时存储多个同类型数据类型变量或对象。 数组格式 声明数组数据类型 [] 数组变量名;例如: 1int[] nums; 或 数据类型 数组变量名[]; 例如: 1int nums[]; 第二种为C/C++的风格, java保留了C/C++的风格。 数组是固定长度的，创建的时候需要设置它的长度 1nums = new int[5]; 给数组的元素分配位置长度为5, 从0开始编号 分别为0 1 2 3 4 (下标 索引) 获取数组中的最大值 1234567public static void getMax() { int[] arr = {256, 1024, 1, 56, 666,12345}; int max = 0; for(int num : arr) max = num &gt; max ? num : max; System.out.println(max);} 数组排序选择排序 12345678910111213141516171819202122232425public static void selectSort() { /* * 256 1024 1 56 666 12345 * 1 1024 256 56 666 12345 * 1 56 256 1024 666 12345 * 1 56 256 666 1024 12345 */ int[] arr = {256, 1024, 1, 56, 666,12345}; for(int i = 0; i &lt; arr.length; i ++) { boolean isLoop = false; for(int j = i + 1; j &lt; arr.length; j ++) { int temp; if(arr[i] &gt; arr[j]) { temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; isLoop = true; } } if(isLoop) break; } for(int num : arr) System.out.println(num);} 冒泡排序 123456789101112131415161718192021222324252627public static void bubbleSort() { /* * 256 1024 1 56 666 12345 * 256 1 56 666 1024 12345 * 1 56 256 666 1024 12345 */ int[] arr = {256, 1024, 1, 56, 666,12345}; for(int i = arr.length; i &gt; 0; i --) { boolean isLoop = false; for(int j = 1; j &lt; i; j++) { int temp ; if(arr[j] &lt; arr[j - 1]) { temp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = temp; isLoop = true; } } System.out.println(\"循环了\" + (arr.length - i + 1) + \"次\"); if(!isLoop) break; } for (int i : arr) { System.out.println(i); }}","link":"/2019/10/18/Java数组/"},{"title":"Java面向对象(方法)","text":"方法签名方法的签名包括 访问修饰符、返回值数据类型、方法名、参数列表 访问修饰符 访问修饰符 开放级别 public 开放权限最高, 公共的 默认(不写权限修饰符) 开放权限为包级别(最大只能在同包下使用) protected 开放权限为继承级别(最大只能在继承的子类使用) private 开放权限为类级别(只能在本类下使用) static修饰(可选修饰) (1)静态的方法中只能使用静态的变量 (2)static修饰的变量或方法, 在程序的编译期就已经分配了内存(慎用) 方法的返回值类型 (1)void 不返回一个值的时候 返回类型为void (2)非void 通过return返回变量或引用 方法名遵守语法规则和约定命名规则 参数列表","link":"/2019/10/22/Java面向对象(方法)/"},{"title":"Java面向对象基本概念","text":"什么是类？抽象的概念物以类聚,同一类事物对象具备了一些相同的规律,我们就称为一类。 main方法不是类的组成部分 什么是对象？具体的实现,万事万物皆为对象类是对象的抽象, 对象是类的实例。 创建一个类一个java文件中一定有且唯一的一个public的类的名字跟java文件名一致公共的public是一种访问修饰符，让其它的java代码可以访问 12345678910111213//1.创建了一个基本的类public class Person{ public static void main(String[] args){ int i; i = 0; //2. 定义了一个Person类型的变量，对象名字叫张三 Person zhangsan; //3. 新建了一个Person类型的对象，实例化 zhangsan = new Person(); }} 一个类中包含有属性(成员变量) 和 方法this 关键字 指代的是当前的类(this所在位置的类) 1234567891011public class Person{ //类的成员变量(属性) 用this.name调用 String name = \"张三\"; public void study(){ //方法study的局部变量 String name = \"李四\"; System.out.println(\"Hello \" + name); }} 构造方法构造方法默认是隐式存在的, 默认有一个无参的构造方法构造方法没有返回值构造方法唯一的作用就是生成(构造 新建)一个类的对象构造方法的名字必须和类名一样 构建一个带参的构造方法用来赋值初始化, 在构建一个对象的时候对属性进行赋值。 12345678910111213141516171819public class Person{ //类的成员变量(属性) 用this.name调用 String name = \"张三\"; public Person(){ } public Person(String name){ this.name = name; } public void study(){ //方法study的局部变量 String name = \"李四\"; System.out.println(\"Hello \" + name); }}","link":"/2019/10/21/Java面向对象基本概念/"},{"title":"Mysql 数据表基本操作","text":"数据库表的基本操作1234567891011121314151617181920212223242526272829303132--INSERT INTO &lt;表名&gt; (&lt;列名列表&gt;) VALUES (&lt;值列表&gt;)INSERT INTO t_student(id,name,age,sex) VALUES(1,'zhangsan',25,'m');INSERT INTO t_student VALUES(2,'lisi',25,'m');INSERT INTO t_student(id,name) VALUES(3,'XY');-- mysql的方言，用于新增多条数据INSERT INTO t_student VALUES(4,'z3',20,'f'),(5,'l4',25,'f'),(6,'w5',19,'f');-- 更新数据,不加限定是整表更新UPDATE t_student SET sex='m';-- 更新指定数据,通过where语句来限定数据范围UPDATE t_student SET sex='f' WHERE name='zhangsan';UPDATE t_student SET age=age+3 WHERE age&lt;=20;-- is not nullUPDATE t_student SET age=18 WHERE age is null;UPDATE t_student SET name='zsf',age=100 WHERE id=1;SELECT * FROM t_student;-- 通过update模拟delete的效果UPDATE t_student SET sex=NULL WHERE name='w5';-- 标准的delete语句，数据的整表删除DELETE FROM t_student;DELETE FROM t_student WHERE sex='f';-- 不记录日志，直接删除数据TRUNCATE TABLE t_student; 指定主键约束(primary key)12345678910111213141516CEATE YABLE t_student( id INT PRIMARY KEY, name VARCHAR(50) NOT NULL);SELECT * FROM t_student;INSERT INTO t_student VALUES(1, `stu01`)-- 主键的特性是 不为NULL 且唯一,下面两行代码将插入失败INSERT INTO t_student(name) VALUES(`stu01`);INSERT INTO t_student VALUES(1, `stu01`);-- 不为空约束，输入字段不能为空INSERT INTO t_student(id) VALUES(2); 指定唯一约束(unique)123456789CREATE TABLE t_student( id INT, name VARCHAR(50) UNIQUE)INSERT INTO t_student VALUES(1, `stu01`)-- 唯一约束即字段不能相同, 下面代码插入失败INSERT INTO t_student VALUES(2, `stu01`) 默认约束(default)123456789CREATE TABLE t_student( id INT PRIMARY KEY, name VARCHAR(50) NOT NULL, age INT, sex CHAR(2) DEFAULT `m`)INSERT INTO t_student VALUES(1, `stu01`, 15, default) 外键约束(foreign key) 创建主表与从表 12345678910111213141516-- 创建主表CREATE TABLE t_class( c_id INT PRIMARY KEY, c_name VARCHAR(50) UNIQUE NOT NULL);-- 创建从表CREATE TABLE t_student( s_id INT PRIMARY KEY, s_name VARCHAR(50) UNIQUE NOT NULL, s_c_id INT, constraint `fk_student_class` foreign key (s_c_id) references t_class(c_id)) 错误的插入顺序 12INSERT INTO t_student VALUES(1, `stu01`, 1);INSERT INTO t_class VALUES(1, `class01`) 应该先插入主表数据，从表在主表外键存在的情况下插入数据 123456INSERT INTO t_class VALUES(1, `class01`)INSERT INTO t_student VALUES(1, `stu01`, 1);-- 如果需要删除相联系的, 与插入的顺序相反DELETE FROM t_student WHERE s_c_id = 1;DELETE FROM t_class WHERE c_id = 1; 创建表后再添加外键12345678910111213141516171819-- 先创建主表CREATE TABLE t_class( c_id INT PRIMARY KEY, c_name VARCHAR(50) UNIQUE NOT NULL)-- 创建从表CREATE TABLE t_student( s_id INT PRIMARY KEY, s_c_id INT REFERENCES t_class(c_id), s_name VARCHAR(50) UNIQUE NOT NULL, s_age INT, s_sex CHAR(2) DEFAULT '男')-- 添加外键的alter table t_student add constraint foreign key(s_c_id) references t_class(c_id); 唯一约束与不为空约束123456789CREATE TABLE t_stuednt( name VARCHAR(50) UNIQUE, id INT NOT NULL)INSERT INTO t_student VALUES(`stu01`, 1)--将先报not null错误，再报unique唯一约束错误INSERT INTO t_student VALUES(`stu01`, null) mysql级联操作 级联操作：是指在删除、更新父表时，对子表进行的相应操作，包括RESTRICT、NO ACTION、CASCADE、SET NULL。 RESTRICT、NO ACTION 作用相同删除：从表记录不存在时，主表才可以删除。删除从表，主表不变更新：从表记录不存在时，主表才可以更新。更新从表，主表不变 CASCADE删除：删除主表时自动删除从表。删除从表，主表不变更新：更新主表时自动更新从表。更新从表，主表不变 SET NULL删除：删除主表时自动更新从表值为NULL。删除从表，主表不变更新：更新主表时自动更新从表值为NULL。更新从表，主表不变 在还没有添加任何的级联操作的时，删除有关联的数据会报错 1DELETE FROM t_class WHERE c_id = 1; 级联操作 - cascade - 注意：Navicat中是新增不是修改，要手动替换1alter table t_student add constraint foreign key(s_c_id) references t_class(c_id) on delete cascade on update cascade; 删除主表中班级id 为 3的1DELETE FROM t_class WHERE c_id = 3; 级联操作 - set null - 注意：Navicat中是新增不是修改，要手动替换12alter table t_student add constraint foreign key(s_c_id) references t_class(c_id) on delete set null on update set null; 删除主表中班级id 为 2的1DELETE FROM t_class WHERE c_id = 2;","link":"/2019/11/26/Mysql DML/"},{"title":"Mysql DQL","text":"SELECT 简介：SELECT查询出来显示的是一个副本 投影 1select name,sex from t_student; 不同表的相同字段，通过前缀区分1select t_student.id from t_student; 不同数据库的相同表明，用前缀区分1select study.t_student from t_student; 列的别名12345678-- 写法一, 列名 as 别名select id as '学号',name as '姓名' from t_student;-- 写法二, 列名 别名select id '学号',name '姓名' from t_student;-- 写法三 列名 别名 可以不加引号，但是加上引号保障别名结构select id 学号,name 姓名 from t_student; 表的别名12select s.s_id, c.c_id, c.c_namefrom t_student as s, t_class as c; select查询后面加上运算123select age + 10from t_stuedntwhere age is not null; 关键字distinct, 用来排除重复的字段, 实现去重效果1select distinct sex from t_student; 关键字limit, 实现分页效果, 带参数limit start_index, offset, Limit是Mysql的方言1234select id,name from t_student-- 从下标1开始,查询长度为5, 如果只有一个参数,下标默认从0开始limit 1,5 模糊查询 关键字like实现模糊查询12-- _代表一个字符，%代表零个或者多个字符 \\实现转义select * from t_student where s_name like '_1%\\_\\%' 排序1234567-- 升序，可以直接order by,默认为order by ascselect * from t_studentorder by asc-- 降序select * from t_student order by desc 聚合函数123456789101112131415161718192021-- count()实现计数,返回查询到的条数总和-- 一般求记录的条数，使用count(id) 效率高select count(id) from t_student;-- 求不重复的字段条数select count(distinct id) from t_student;-- 可以接多个表达式select count(distinct id,s_name) from t_student;-- sum()实现求和，返回该字段累加的和，一般用于数字，如果是字符，则没有查询结果select sum(id) from t_student;-- avg()实现求平均数，返回字段的平均数,与sum类似select avg(id) from t_student;-- max()实现求最大值,返回该字段的最大值select max(id) from t_student;-- min()实现求最小值,返回该字段的最小值select min(id) from t_student; 数据组合 当查询不同组的时候123select count(*) from t_student where s_class = 'classo1';select count(*) from t_student where s_class = 'classo2';select count(*) from t_student where s_class = 'classo3'; 现在有一个group by关键字来分组查询1234select class,count(class) as '人数'from t_studentwhere class is not nullgroup by class; group by 至此接入多个参数1234select class as '班级',age as '年龄',count(*) as '数量'where class is not nulland age is not nullgroup by class,age; mysql方言group by弊端在mysql中，group by后面的字段没有强制性的要求select输出，可能造成分组字段与select后字段不匹配，照成视觉上的错误。 having关键字having关键字 是聚合函数加入条件查询中 1234select count(*)from t_studentgroup by agehaving avg(age) &gt; 17 sql执行顺序1234567select avg(mark) -- 4 from sorce -- 1 where mark &gt; 60 -- 2 group by id -- 3 having avg(mark) &gt; 0 -- 5 order by desc -- 6 limit 1,5 -- 7 练习题一 创建数据表班级表123456789create table t_class( c_id int auto_increment primary key, c_name varchar(50) not null unique)insert into t_class(c_name) values('奋斗班')insert into t_class(c_name) values('粪斗班')insert into t_class(c_name) values('奋逗班') 学生表 1234567891011121314151617181920212223create table t_student( s_id int auto_increment primary key, s_name varchar(50) unique, s_sex varchar(2) default('男'), s_age int, s_c_id int, constraint `pk_student_class` foreign key(s_id) references t_class(c_id))insert into t_student(s_name,s_sex,s_age,s_c_id) values('刘基','男','18',1);insert into t_student(s_name,s_sex,s_age,s_c_id) values('李伯','男','12',1);insert into t_student(s_name,s_sex,s_age,s_c_id) values('陈涛涛','男','22',1);insert into t_student(s_name,s_sex,s_age,s_c_id) values('郑欢欢','女','18',1);insert into t_student(s_name,s_sex,s_age,s_c_id) values('陈星星','男','8',2);insert into t_student(s_name,s_sex,s_age,s_c_id) values('张伯','男','17',2);insert into t_student(s_name,s_sex,s_age,s_c_id) values('陈伯','男','16',2);insert into t_student(s_name,s_sex,s_age,s_c_id) values('刘基','男','28',2);insert into t_student(s_name,s_sex,s_age,s_c_id) values('陈基','男','9',3);insert into t_student(s_name,s_sex,s_age,s_c_id) values('刘基','男','9',3);insert into t_student(s_name,s_sex,s_age,s_c_id) values('张伯','男','9',3);insert into t_student(s_name,s_sex,s_age,s_c_id) values('高基','男','29',3); 解答123456789101112131415161718192021222324252627282930313233-- 把刘基的名字修改为刘伯温update t_studentset s_name = '刘伯温'where s_name = '刘基'-- 唐伯虎年龄20，性别男，班级3，添加到表中 insert into t_student(s_name,s_sex,s_age,s_c_id) values('唐伯虎','男','20',3)-- 查询出所有姓名包括伯的所有的人员的信息select *from t_studentwhere s_name like '%伯%'-- 查询年龄在10-20之间的男性所有人员的信息select *from t_studentwhere s_sex = '男'and s_age between 10 and 20-- 查询年龄在10-20之间的所有人员前5条的信息(以年龄大小排序) 并且将查询出的每个人的年龄加10select s_name,s_sex,s_age + 10,s_c_idfrom t_studentwhere s_age between 10 and 20and s_age is not nullorder by s_age desclimit 5-- 查询年龄在10岁以下或20岁以上的所有人员的姓名和年龄前5条的记录，并且将查询出的每个人的年龄加10，并且不能重复 并且给每个字段起一个别名select distinct s_name as '姓名', s_age + 10 as '年龄'from s_studentwhere s_age &lt; 10 or s_age &gt; 20limit 5; 练习题二 创建数据表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455-- 商品类别表 --CREATE TABLE category( cat_id INT PRIMARY KEY AUTO_INCREMENT, --类别编号 cat_name VARCHAR(30) NOT NULL --类别名称);-- 商品表 --CREATE TABLE goods( goods_id INT PRIMARY KEY AUTO_INCREMENT, --商品编号 goods_name VARCHAR(30) NOT NULL, --商品名称 goods_price DOUBLE, --商品进价 shop_price DOUBLE, --商品卖价 market_price DOUBLE, --市场价 cat_id INT, --商品类别 goods_number INT, --商品数量 FOREIGN KEY(cat_id) REFERENCES category(cat_id));INSERT INTO category(cat_name) VALUES('航模'),('车模'),('船模'),('动物模型');INSERT INTO goods(goods_name,goods_price,shop_price,market_price,cat_id,goods_number) VALUES('F16战斗机',300,1000,900,1,120);INSERT INTO goods(goods_name,goods_price,shop_price,market_price,cat_id,goods_number) VALUES('F35战斗机',400,1200,1000,1,210);INSERT INTO goods(goods_name,goods_price,shop_price,market_price,cat_id,goods_number) VALUES('F117隐形轰炸机',290,800,600,1,99);INSERT INTO goods(goods_name,goods_price,shop_price,market_price,cat_id,goods_number) VALUES('牧马人',120,600,500,2,1200);INSERT INTO goods(goods_name,goods_price,shop_price,market_price,cat_id,goods_number) VALUES('宝马Z4',130,560,510,2,231);INSERT INTO goods(goods_name,goods_price,shop_price,market_price,cat_id,goods_number) VALUES('地中海帆船',90,300,180,3,68);INSERT INTO goods(goods_name,goods_price,shop_price,market_price,cat_id,goods_number) VALUES('密西西比号蒸汽明轮',100,560,520,3,114);INSERT INTO goods(goods_name,goods_price,shop_price,market_price,cat_id,goods_number) VALUES('德鲁伊号16门炮护卫舰',1322,2322,2600,3,100);INSERT INTO goods(goods_name,goods_price,shop_price,market_price,cat_id,goods_number) VALUES('皇家理查德号 74门炮战舰',350,800,769,3,312); 解答123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657-- 查询每个类别下商品种类数select c.cat_name as 类别,count(*) as '数量'from goods as g, category as cwhere g.cat_id = c.cat_idgroup by g.cat_id-- 查询本店每个商品价格比市场价低多少；select market_price-shop_price as '商品价格比市场价低' from goods-- 查询每个类别下面积压的货款select c.cat_name as 类别,sum(goods_price) as '积压贷款'from goods as g, category as cwhere g.cat_id = c.cat_idgroup by g.cat_id-- 查询本店商品价格比市场价低多少钱，输出低200元以上的商品select * ,(market_price-shop_price) as '差价'from goodswhere market_price-shop_price &gt; 200-- 查询积压货款超过2万元的类别，以及该类别积压的货款select *,sum(goods_price * goods_number) as '积压贷款'from goods as g, category as cwhere g.cat_id = c.cat_idgroup by g.goods_idhaving sum(goods_price * goods_number) &gt; 20000-- 按类别号升序排列，每个类别下的商品进价降序排列select *from goodsorder by cat_id asc, goods_id desc-- 取价格第1-6高的商品select *from goodsorder by goods_price desclimit 6-- 查询每个类别下进价最高的商品select *from goodswhere goods_price in ( select max(goods_price) from goods group by cat_id)group by cat_id-- 取出每个类别下最新的产品(goods_id唯一)select *from goodswhere goods_id in ( select max(goods_id) from goods group by cat_id)group by cat_id","link":"/2019/11/27/Mysql DQL/"},{"title":"windows-mysql8.0.15 修改密码、重置密码方法","text":"以管理员方式运行cmd,然后再关闭mysql服务1C:\\&gt; net stop mysql 开启跳过密码验证登录的MySQL服务，命令执行后该命令框会出现很多执行代码，不要关闭该窗口。1C:\\&gt; mysqld --console --skip-grant-tables --shared-memory 再打开一个新的cmd，无密码登录MySQL1C:\\&gt; mysql -u root 选择mysql数据库(因为user表在该数据库下)1mysql&gt; user mysql; 将密码置为空，然后输入命令quit退出，下次登录将不会使用密码。修改之前与修改之后flush刷新。1234mysql&gt; flush privileges;mysql&gt; update user set authentication_string='' where user='root';mysql&gt; flush privileges;mysql&gt; quit 上面操作是以跳过密码验证方式进入mysql，权限不够。继续以下操作将能修改密码。 再次进入mysql数据库，本次要求输入密码，直接回车就行。1C:\\&gt; mysql -u root -p 同样在更改前后，flush刷新1234mysql&gt; flush privileges;mysql&gt; alter user ‘root’@’localhost’IDENTIFIED BY ‘你的密码’;mysql&gt; alter user ‘root’@’%’IDENTIFIED BY ‘你的密码’;mysql&gt; flush privileges; 最后尝试一下登录 在使用Navicat登录本地账户时由于高版本密码加密方式为caching_sha2_password加密,有可能出现以下错误: 因此将加密方式改为mysql_native_password方式加密代码如下: 12345678# 查看加密方式mysql&gt; user,plugin from user where user='root';# 更改加密方式和密码mysql&gt; alter user 'root'@'%' identified with mysql_native_password by '你的密码';# 或者是另外一种mysql&gt; alter user 'root'@'localhost' identified with mysql_native_password by '你的密码';# 修改完刷新mysql&gt; flush privileges; 最后成功修改，可登入navicat 12# 再次查看加密方式mysql&gt; user,plugin from user where user='root';","link":"/2019/11/25/Mysql 忘记密码处理/"},{"title":"Mysql 安装与配置","text":"下载解压版官网下载网址:https://dev.mysql.com/downloads/mysql/ 解压选择一个路径解压压缩包 如: d:\\mysql 安装服务以管理员的方式打开cmd, 切换到安装目录下bin文件夹 。 d:\\mysql\\mysql-8.0.18-win64\\bin 1d:\\mysql\\mysql-8.0.18-win64\\bin &gt; mysqld -install 配置mysql输入命令mysqld –initialize，回车执行命令后需要等待一小会儿，这个过程会在MYSQL的解压目录mysql-5.7.21-winx64下生成一个data的文件夹，里面有一个后缀名为.err结尾的文件 1d:\\mysql\\mysql-8.0.18-win64\\bin &gt; mysqld –initialize 该文件里会有一个默认的初始密码 找到随机密码之后，我们先来配置一下MYSQL的启动文件，在MYSQL的解压目录mysql-5.7.21-winx64下新建一个.ini格式文件my.ini，然后以记事本格式打开写入下面代码： 1234[mysqld]basedir=C:\\mysql-5.7.20-winx64datadir=C:\\mysql-5.7.20-winx64\\dataport=3306 然后启动服务 1d:\\mysql\\mysql-8.0.18-win64\\bin &gt; net start mysql 输入命令登录, 改密码为临时密码 12d:\\mysql\\mysql-8.0.18-win64\\bin &gt; mysql -u root -pEnter password:***** 进入mysql界面开始修改密码 1mysql &gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;密码&apos;; 接下来就配置环境变量，在path中添加mysql的安装目录下的bin目录(d:\\mysql\\mysql-8.0.18-win64\\bin)","link":"/2019/11/22/Mysql 安装与配置/"},{"title":"Mysql 练习","text":"创建表 商品基本信息表(shop_jb) 名称 字段名 类型和约束 商品编号 （jb_id） 主键 自增长 商品名称 （jb_name） 字符串型 不为空 不能重复 规格 （jb_spec） 字符串型 不能为空 库存量 （jb_stock） 整型 不能为空 默认为0 进货价 （jb_price） 浮点型 不能为空 进货日期 （jb_date） 日期型 12345678910111213create table shop_jb(-- sql server方言-- jb_id int identified(1,1) primary key-- mysql方言 jb_id int auto_increment primary key, jb_name varchar(50) not null unique, jb_spec varchar(50) not null, jb_stock int not null default(0), jb_price float not null, jb_date date) 商品销售表（shop_xs） 名称 字段名 类型和约束 商品销售表id （xs_id） 主键 自增长 商品编号 （xs_jb_id) 外键 不能为空 销售单价 （xs_sale） 默认是0 不能为空 销售量 （xs_quantity） 默认是0 不能为空 销售日期 （xs_date） date 业务员编号 （xs_ywid） 外键 不能为空 12345678910111213create table shop_xs( xs_id int auto_increment primary key, xs_jb_id int not null, xs_sale int default(0) not null, xs_quantity int default(0) not null, xs_date date, xs_yw_id int,-- 外键名 切记使用Esc键下的`符号, 而不要使用单引号 constraint `pk_xs_jb` foreign key (xs_jb_id) references shop_jb(jb_id), constraint `pk_xs_yw` foreign key (xs_yw_id) references shop_yw(yw_id)) 业务员表（shop_yw） 名称 字段名 类型和约束 业务员编号 （yw_id） 主键 自增长 姓名 （yw_name） 字符串型 不为空 性别 （yw_sex） 默认‘男’ 年龄 （yw_age） 不能为空 电话 （yw_tel） 字符串型 不能为空 住址 （yw_address） 字符串型 不能为空 薪水 （yw_salary） 浮点型 1234567891011121314create table shop_yw(-- sql server方言-- yw_id int identified(1,1) primary key-- mysql方言 yw_id int auto_increment primary key, yw_name varchar(50) not null, yw_sex char(2) default('男'), yw_age tinyint not null, yw_tel varchar(50) not null, yw_address varchar(50) not null, yw_salary float) 练习题 删除业务员表中姓名为‘张三’的数据12delete from shop_yw where yw_name = '张三'; 将业务员表中年龄18-20的员工薪水更改为15001234update shop_yw set yw_salary = 1500 where age &gt; 18 and age &lt; 20; 删除商品销售表中销售日期大于2019-1-9的记录12delete from shop_xs where xs_date = '2019-1-9'; 将业务员表中姓名为‘赵六’开头并且电话为13999090980 的薪水改为5000，性别改为女123update shop_yw set yw_salary = 5000, yw_sex = '女'where yw_name = '赵六' and yw_tel = '13999090980'; 修改业务员表中小于18岁的数据，年龄都增加5岁1234update shop_yw set yw_age = yw_age + 5where yw_age &lt; 18and yw_age is not null; 修改商品信息表中库存量为0并且进货价为0的数据 分别改为100和15.221234update shop_jbset jb_stock=100, jb_price = 15.22where jb_stock = 0and jb_price = 0; 修改商品信息表中 商品名称为‘五粮液’开头 的进货日期改2019-1-1123update shop_jbset jb_date = '2019-1-1'where jb_name = '五粮液'; 删除商品销售表中商品编号为3，并且业务员编号为2的所有数据123delete from shop_xswhere xs_id = 3and xs_yw_id = 2; 用TRUNCATE和delete删除商品销售表中所有信息12","link":"/2019/11/27/Mysql 练习/"},{"title":"Mysql用户操作","text":"创建可在任意ip登录的用户1create user 'new_test'@'%' identified by '123456'; 创建指定ip: 192.118.1.1 登录的用户1create user '用户名'@'192.118.1.1' identified by '密码'; 创建指定ip: 以192.118.1. 开头 登录的用户1create user '用户名'@'192.118.1.%' identified by '密码'; 修改用户名1rename user 'new_test'@'%' to 'test'@'%'; 修改密码1set password for 'test'@'%'=Password('666'); 查看当前用户权限1show grants for 'root'@'localhost'; 通过root给其它账号授权12grant insert,delete,update,select on study.student to \"test\"@'%';grant all privileges on *.* to \"用户名\"@'%'; 通过root收回其它账号授权12revoke all on study.student from 'test' @\"%\";revoke all on *.* from '用户名'@'%'; 刷新权限1FLUSH PRIVILEGES;","link":"/2019/11/26/Mysql 用户操作/"},{"title":"Mysql 表联接","text":"笛卡尔乘积 两张表的行数相乘通过表联接来克服这种高消耗的查询 内联接 t1 join on t2(t1 inner join on t2) 如果select * form t1,t2 连接,查询数据将会是t1的条数 * t2的条数如果根据select * from t1 join on t2 将根据外键链接查询, 减少检索条数 外联接 左外联接 主表为student, 匹配表class;根据主表所有数据放在左边,匹配表无匹配值则为NULL 1234SELECT *FROM student LEFT JOIN class ON student.s_c_id = class.c_id; 右外联接 与左外链接相似,即：主表，匹配表互换 全外连接 Mysql不支持 外联接实现 Oracle方言，Mysql不知此‘+’表示补充，哪个表有’+’,那么这个表就是匹配表 123SELECT * FROM student,class ON student.s_c_id = class.c_id(+); 自联接(内联接) 自联接就是一个特殊的内联接 123SELECT e.ename AS '雇员' ,m.ename AS '主管' FROM emp e JOIN emp m ON e.mgr = m.empno;","link":"/2019/11/29/Mysql 表联接/"},{"title":"Mysql 良好的数据库设计","text":"为什么需要设计数据库 良好的数据库设计 节省数据的存储空间 数据的重复 能够保证数据的完整性 方便进行数据库应用系统的开发 糟糕的数据库设计 数据冗余、存储空间浪费 内存空间冗余 数据的更新和插入异常 良好的数据库设计必须遵守的范式 第一范式 在所有的范式中，第一范式是最重要的。它提供了建立其他范式的基础，并且代表了表的核心特性 一行的每个列必须是原子性的，即任何给定行的列只能包含一个值一个表中的所有行必须是不同的。虽然可能包含相同的值，但是每一行都必须作为一个整体存在表中的 第二范式 第二范式在第一范式基础上扩展,必须先符合第一范式 第二范式需要确保数据表中的每一列都和主键相关一个表中只能保证一种数据，不可以吧多种数据保存在同一张数据表中 第三范式 第三范式在第二范式基础上扩展,必须先符合第二范式 确保数据表中的每一列数据和主键直接相关,而不能是间接相关 总结 * 范式 要求 1NF 无重复的列 2NF 属性完全依赖于主键 3NF 属性不依赖于其它非主属性(即没有传递依赖)","link":"/2019/11/29/Mysql 良好的数据库设计/"},{"title":"Netty入门理解","text":"定义.Netty是一个异步事件驱动网络应用框架","link":"/2020/01/03/Netty入门理解/"},{"title":"Mysql 高级查询","text":"SQL子查询 SELECT使用嵌套子查询123select s_id as '学号', s_name as '学生姓名', (select c_name from class where c_id = s_c_id) as '班级'from student FROM使用嵌套子查询123select s.s_id as '学号', s.s_name as '学生姓名', c.c_name as '班级'from student as s,(select * from class) as cwhere c.c_id = s.s_c_id WHERE使用嵌套子查询123select s.s_id as '学号', s.s_name as '学生姓名', c.c_name as '班级'from student as swhere s.s_c_id in (select c_id from class) SOME 与 ANG 于 EXIST使用123select s.s_id as '学号', s.s_name as '学生姓名', c.c_name as '班级'from student as swhere s.s_c_id &gt; SOME(select c_id from class) 123456select * from student s1where s_score &gt; ( select avg(s_score) from student s2 where s1.s_c_id = s2.s_c_id group by s_c_id) 函数使用 平均服务期限 AVG(TIMESTAMPDIFF(MONTH, e.hiredate, ‘2019-11-28’)) IFNULL(e.comm,0) 这个函数的作用是如果e.comm字段的为null，则将其转换为0 SOME,ANY,IN,ALL,EXISTS SOME,ANY 外部字段 至少大于该集合中一个字段，与逻辑运算符结合使用 IN 外部字段 是否存在于字段集合当中，相当于 = SOME 或 = ANY ALL 外部字段 必须大于该集合中所有字段，与逻辑运算符结合使用 EXISTS 只与子查询相关，即，子查询是否返回字段，对应TRUE与FALSE 练习题 建表 dept部门表(deptno 部门编号 / dname 部门名称 / loc 地点)12345create table dept( deptno int primary key, dname varchar(14), loc varchar(13)); emp员工表(empno员工号/ename员工姓名/job工作/mgr上级人员编号/hiredate受雇日期/sal薪金/comm佣金/deptno部门编号)1234567891011create table emp( empno int not null primary key, ename varchar(10), job varchar(10), mgr int, hiredate datetime, sal double, comm double, deptno int, foreign key(deptno) references dept(deptno)); 解题 (1)．列出至少有一个员工的所有部门。 1234567select * from deptwhere deptno in ( select distinct deptno from emp group by deptno having count(deptno) &gt; 1) (2)．列出薪金比“SMITH”多的所有员工。 12345select * from empwhere sal &gt; ( select sal from emp where ename = 'SMITH') (3)．列出所有员工的姓名及其直接上级的姓名。 123select e1.ename as '姓名',e2.ename as '直接上级'from emp as e1,(select empno,ename from emp) as e2where e2.empno = e1.mgr (4)．列出受雇日期早于其直接上级的所有员工。(同上,日期可直接拿来比较) 12345select * from emp as e1where e1.hiredate &gt; ( select hiredate from emp as e2 where e2.empno = e1.mgr) (5)．列出所有工作为“CLERK”（办事员）的姓名及其部门名称。 1234select ename '名字',dname '部门名字'from emp,deptwhere emp.deptno = dept.deptnoand emp.job = 'CLERK' (6)．列出在部门“SALES”（销售部）工作的员工的姓名，假定不知道销售部的部门编号。 1234567select enamefrom empwhere deptno = ( select deptno from dept where dname = 'SALES') (7)．列出薪金高于公司平均薪金的所有员工。(反复查自己) 123456select *from empwhere sal &gt; ( select avg(sal) from emp) (8)．列出与“James”从事相同工作的所有员工。(排除自己) 123456select *from emp where job = ( select job from emp where ename = 'James')and ename != 'James' (9)．列出薪金等于部门30中员工的薪金的所有员工的姓名和薪金。 1234567select ename '姓名',sal '薪金'from empwhere sal in ( select distinct sal from emp where deptno = 30)and deptno != 30 (10)．列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金。 1234567select ename '姓名',sal '薪金'from empwhere sal &gt; ( select max(sal) from emp where deptno = 30)and deptno != 30 (11)．列出在每个部门工作的员工数量、平均工资和平均服务期限。 1234select count(empno) '员工数量',avg(sal+IFNULL(comm,0)) '平均工资',avg(TIMESTAMPDIFF(MONTH, emp.hiredate, '2019-11-28')) '平均服务期限'from empgroup by deptno (12)．列出所有员工的姓名、部门名称和工资。 123select ename '姓名', dname '部门名称', sal+IFNULL(comm,0) '工资' from emp, deptwhere emp.deptno = dept.deptno","link":"/2019/11/28/Mysql 高级查询/"},{"title":"初识Mysql","text":"什么是SQL SQL是结构化查询语言(Structured Query Language) 一种用于管理关系型数据库，与数据库中的数据进行通讯得到计算机标准语言(方言) 数据库名字要求 第一个字符必须是下列字符之一：Unicode 标准 3.0 所定义的字母（Unicode 中定义的字母包括拉丁字母 a-z 和 A-Z，以及来自其它语言的字母字符）。下划线 (_)、at 符号 (@) 或者数字符号。 后续字符可以是：Unicode 标准 3.0 所定义的字母。来自基本拉丁字母或其它国家/地区脚本的十进制数字。at符号（@）、美元符号 ($)、数字符号或下划线。标识符不能是所用RDBMS的保留字。 table database不允许嵌入空格或其它特殊字符。 创建表，字段要求 名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-1038 DOUBLE 浮点型 8字节浮点数，范围约+/-10308 DECIMAL(M,D) 高精度小数 由用户指定精度的小数 CHAR(N) 定长字符串 存储指定长度的字符串，例如：CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2018-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59 注意：M：整数位+小数位为总位数，D为小数位，M必须大于D,REAL又可以写成FLOAT(24)。 DOS下操作mysql12345678910111213# 连接mysql数据库mysql -u root -p# 出现Enter Password:******# 输入你的密码 进入mysql# 显示所有数据库show databases;# 创建数据库create database study;# 使用数据库use study;# 创建数据表create table student(s_id INT, s_name VARCHAR(20)); 实际执行操作效果如下： 开始对数据表进行操作123456-- 显示所有的数据表show tables;-- 显示表中数据select * from student;-- 向数据表中插入数据insert into student values(1,'小黑'); 删除数据表和数据库1234567-- 删除数据表studentdrop table student;show tables;-- 删除数据库study;drop database study;show databases; 修改表名和字段123456789101112131415161718-- 把表old_name更名为新名字new_namealter table old_student rename new_student;-- ALTER TABLE &lt;表名&gt; MODIFY &lt;属性名 数据类型&gt;;-- 修改字段数据类型alter table new_student modify name varchar(30);-- ALTER TABLE &lt;表名&gt; CHANGE 旧属性名 新属性名 新数据类型;-- 修改字段名与数据类型alter table new_student change name stu_name varchar(40);-- ALTER TABLE 表名 ADD 属性名1 数据类型 [完整性约束条件] [FIRST | AFTER 属性名2];-- 增加表字段alter table new_student add teacher_name varchar(20) NOT NULL AFTER id;-- ALTER TABLE 表名 DROP 属性名;-- 删除表字段alter table new_student drop teacher_name; 显示表结构12# 显示表new_student表的结构信息describe new_student; 复制表1234567-- 在MySQL中，下面的语句创建一个名MY_t_class的新表，该表是复制了t_class表的数据和结构（列、数据类型）CREATE TABLE MY_t_class SELECT * FROM t_class;-- 复制表的同时表的约束并不能复制过来。所以，推荐使用CREATE TABLE语句创建基本的列和数据类型，-- 然后使用ALTER TABLE命令添加所有其它约束。如果是只复制表结构，不复制数据，只需要在WHERE子-- 句中添加一个永远不等于true的条件即可。CREATE TABLE MY_t_class SELECT * FROM t_class WHERE 1=0; 使用自增机制123456789101112-- 在MySQL数据库中，提供了一种自动为列产生数值的机制。这种自动产生值的字段通常与主键约束一起配合使用。-- MySQL使用auto_increment来实现列的自增长，例如：CREATE TABLE t_class( c_id INT PRIMARY KEY AUTO_INCREMENT,--定义自增长 c_name VARCHAR(50) UNIQUE NOT NULL);--增加数据时可以不为自增长列设定值INSERT INTO t_class(c_name) VALUES('t01');-- MySQL中，自增长序号是从1开始，每次递增1。也可以通过下面的代码设置起始序号：ALTER TABLE t_class AUTO_INCREMENT=100000","link":"/2019/11/25/初识mysql/"},{"title":"初识Java","text":"一.学习路线 前置 Java SE Java EE 框架-项目 扩展高级的应用 二.认识Java1995年5月23日Java诞生JDK(Java Develop Kit)JRE(Java Run Environment) 三.Java技术特点 简单性 (1)Java与C++的风格类似。 (2)Java比C++简单,没有头文件、指针等。 (3)提供了丰富的类库,方便程序的开发。 面向对象的语言 万物皆对象 oo编程 Oriented Object 一种与平台无关的语言 (1)测试代码 创建一个文件Study01.java 12345public class Study01{ public static void main(String[] args){ System.out.print(\"Hello World\"); }} (2)运行代码 Win+R打开CMD 切换到java文件所在目录,执行以下代码 12javac Study01.javajava Study01 (3)程序运行过程 Java源程序 –&gt; Compiler编译成 .class的文件 –&gt; JVM(Java Virtual Machine) 解释(interpreter),翻译到不同平台 健壮性和安全性 (1)删除了指针和释放内存,避免了非法内存操作 (2)垃圾回收机制 多线程 四.Java要求 源文件取名要求 只能以英文字母开头,第二位开始可以是数字 开头的字母要大写 每个单词开头的字母要大写 五.C/S和B/S项目区分C代表Client B代表Browser S代表Server六.Java标识符 什么是标识符? 计算机中特殊的表示方式，代表某一些含义 Java标识符命名规定 (1).可以是英文字母(A-Z a-z) 美元符($) 下划线()开始 (2).首字符之后可以是数字 英文字母(A-Z a-z) 美元符($) 下划线()的任意字符组合 (3).Java标识符大小写敏感, Hello 与 hello 是不同的 (4).长度无限制,长度不要太长 (5).关键字不可以做标识符 Java标识符命名规定 (1).驼峰命名法 (2).类的名字: 每一个单词的首位字母大写 (3).见名知意, 名字的命名尽量表示功能和含义 七.数据类型 数字类型 (1).整数 8位 16位 32位 64位 (2).小数 32位 64位 小数的默认类型为double如 123.456 12345678910111213141516public class Study01 { public static void main(String[] args) { // 8位 byte byte b = 0; // 短整型 short s = 1234; // 32位 标准整型 int i = 123; // 64位 长整型 long l = 123456789L; // 32位 单精度浮点型 float = 123.45f; // 64位 双精度浮点型 double = 123456.789d; }} 字符类型 (1).单个字符char 1234567891011public class Study02 { public static void main(String[] args) { char ch = '啊'; System.out.println(\"char类型的ch的值为: \" + ch); //整数转字符 int i = 'a'; System.out.println(\"int类型的i的值为: \" + i); char ch01 = 97; System.out.println(\"char类型的ch01的值为: \" + ch01); }} 八.转义字符转义字符是用来表示控制字符和特殊字符,它由一个反斜杠开头’'后面跟上一个字符 12345char c = '\\\\';System.out.println(c);/* output: * \\ */ 九.各种类型默认值 基本数据类型 位数 默认值 byte 8 0 short 16 0 int 32 0 long 64 0 float 32 0.0 double 64 0.0 char 16 /u0000 boolean 1 false 12345678910111213141516171819202122232425262728293031323334353637public class Study03 { static byte b; static short s; static int i; static long l; static float f; static double d; static char c; static boolean bool; static String str; //main方法是一个静态的方法,在它的内部只能使用静态的变量 public static void main(String[] args) { System.out.println(\"byte: \" + b); System.out.println(\"short: \" + s); System.out.println(\"int: \" + i); System.out.println(\"long: \" + l); System.out.println(\"float: \" + f); System.out.println(\"double: \" + d); System.out.println(\"char: \" + c); System.out.println(\"boolean: \" + bool); System.out.println(\"String: \" + str); }}/** output: * byte: 0 * short: 0 * int: 0 * long: 0 * float: 0.0 * double: 0.0 * char: * boolean: false * String: null */ 十.变量命名规范 什么是变量？ 变量是指没有固定的值，可以改变的数，存储信息(数据)的容器 变量三要素 数据类型: 决定了内存中分配的空间 变量名: 空间别名 值: 空间中存储的数据 变量命名的规范 (1).见名知意 (2).第一个单词首字母小写 十一.什么是常量?1.final修饰的变量为常量，不可修改2.常量的变量名为全大写3.常量的变量名为多个单词时，使用下划线分割 1public final static double PI = 3.1415926535; 练习题1.输入一整数作为秒数，在控制台按小时，分钟，秒的格式输出(如输入600，页面显示：0小时10分0秒) 123456789101112public void printTime(){ System.out.println(\"请输入一个整数:\"); Scanner scan1 = new Scanner(System.in); int num1 = scan1.nextInt(); int h = 0, m = 0, s = 0; s = num1 % 60; m = (num1 / 60) % 60; h = (num1 / (60 * 60)) % 60; System.out.println(h + \"小时\" + m + \"分钟\" + s +\"秒\");} 2.输入一整数，在控制台按倒序的格式输出(如输入2019，页面显示：9102 ) 1234567891011public void reverse{ System.out.println(\"请输入一个4位数整数:\"); Scanner scan2 = new Scanner(System.in); int num2 = scan2.nextInt(); int one = 0, two = 0,three = 0,four = 0; one = num2 / 1000; two = (num2 - one * 1000) / 100; three = (num2 - one * 1000 - two * 100) / 10; four = num2 - one * 1000 - two * 100 - three * 10; System.out.println(four + \"\" + three + \"\" + two + \"\" + one);}","link":"/2019/10/12/初识Java/"},{"title":"初识HTML","text":"HTML引入点击此处查下以下代码演示效果 12345678910111213&lt;html&gt;&lt;head&gt; &lt;meta charset='utf-8'/&gt; &lt;title&gt;welcome&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;p标签-段落显示&lt;/h3&gt; &lt;p align=\"center\"&gt;演示p标签-align属性(center,left,right)&lt;/p&gt; &lt;h3&gt;hr标签-水平线&lt;/h3&gt; &lt;hr size=10 color = red width = 90%/&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2019/12/05/初识HTML/"},{"title":"学习Dubbo","text":"Web应用架构的演变网站应用的规模不断扩大，Web应用架构也在不断的演变 四个阶段： 单一应用、垂直应用、分布式服务、流动计算单一应用架构当网站访问量很小时，只需要一个应用程序，将所有的功能都部署在一起，以减少部署节点和成本。 关键问题：简化数据库操作，数据访问ORM是核心 适用场景：小型网站、管理系统、简易办公系统 局限: 1. 扩展性差 2. 不便于协同开发 3. 不利于升级维护 垂直应用架构当访问量逐渐增大，单一应用(单机)负载太大，此时可以增加服务器来进行负载均衡，提高响应速度，即集群。 但是，当增加的服务器到达一定的数据时所带来的加速的会越来越小。 此时，需要将系统的业务拆分，分别部署在独立的服务器上，以提高效率，称为垂直应用。 优点: 通过拆分项目的业务，实现业务的独立，降低了开发和维护的难度，便于协同开发，提高了扩展性。 局限: 每个垂直模块都有相同的内容, 公共资源无法服用，且业务逻辑与界面无法分离。 加速前端页面开发MVC框架(MVVM) 分布式服务架构当垂直应用越来越多的时候，应用之间交互无法避免，有些业务系统无法完全拆分为独立的系统。 此时，可以将核心业务抽取出现，作为独立的服务Service，逐渐的形成稳定的服务中心, 使前端应用能够更好的适应市场需要的变化。服务之前通过RPC进行远程调用提高业务的利用以及整合分布式服务框架(Remote Procedure Call 远程过程调用) 流动计算架构当服务越来越多，服务之间的调用和依赖关系也越来复杂，诞生了面向服务监听架构体系 (SOA:Service-Oriented Architecture)容差的评估，小服务资源的浪费等问题开始出现。 不同的服务器之间的请求数量差距(负载)，而造成的资源的浪费。添加一个调度中心，基于访问压力实时的管理集群容量，提高集群利用率 RPC简介 RPC:Remote Procedure Call (远程过程调用) 是一种进程间的通信方式 允许应用程序调用网络上另一个应用程序方法 对于服务的消费者而言,无需调用程序的底层 执行过程 client –&gt; Client Stub –&gt; Server Stub –&gt; Server 客户端发起调用请求 客户端存根 对请求参数进行序列化 客户端存根 服务器存根 发送消息 服务器存根 对接收到的消息 进行反序列化 服务器存根 发送请求调用本地方法 服务器执行业务处理 服务器返回处理结果 服务器存根 对处理结果进行序列化操作 服务器存根 将结果返回给 客户端存根 客户端存根 对接收到的结果进行反序列化 客户端存根 将结果返回给 客户端 Dubbo简介 Dubbo是什么 Apache Dubbo是一款高性能的Java RPC框架 提供了三个核心功能: 面向接口的远程方法调用 智能容错的负载均衡,以及服务自动注册和发现 服务自动注册和发现 Dubbo体系结构","link":"/2019/09/10/学习Dubbo/"},{"title":"第一次学习zookeeper笔记","text":"了解zookeeper","link":"/2019/09/10/学习zookeeper/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"JavaEE","slug":"JavaEE","link":"/tags/JavaEE/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Dubbo","slug":"Dubbo","link":"/tags/Dubbo/"},{"name":"zookeeper","slug":"zookeeper","link":"/tags/zookeeper/"}],"categories":[{"name":"JavaSE","slug":"JavaSE","link":"/categories/JavaSE/"},{"name":"JavaEE","slug":"JavaEE","link":"/categories/JavaEE/"},{"name":"Mysql","slug":"Mysql","link":"/categories/Mysql/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"集群","slug":"集群","link":"/categories/集群/"}]}